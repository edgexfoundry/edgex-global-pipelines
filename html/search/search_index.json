{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"EdgeX Global Pipelines","text":""},{"location":"#summary","title":"Summary","text":"<p>This repository contains useful Jenkins global library functions used within the EdgeX Jenkins ecosystem. It provides pre-built pipelines to build and publish Go/C++ based source code in a consistent manner. There are also a lot of utility functions that allow for things like automated vulnerability scanning via Snyk, code coverage tracking via CodeCov.io and many other things. Below you will find some useful links as well as links to all of our documented pipelines.</p> <p>Please note: Documentation is still under heavy development.</p>"},{"location":"#useful-links","title":"Useful Links","text":"<ul> <li>Source Code</li> <li>EdgeX Jenkins Server</li> <li>Jenkins Shared Libraries</li> </ul>"},{"location":"#jenkins-shared-libraries","title":"Jenkins Shared Libraries","text":"<ul> <li>edgeXBuildCApp</li> <li>edgeXBuildDocker</li> <li>edgeXBuildGoApp</li> <li>edgeXBuildGoMod</li> <li>edgeXBuildGoParallel</li> <li>edgeXClair</li> <li>edgeXCodecov</li> <li>edgeXDocker</li> <li>edgeXDockerLogin</li> <li>edgeXEmail</li> <li>edgeXEmailUtil</li> <li>edgeXGHPagesPublish</li> <li>edgeXGeneric</li> <li>edgeXInfraLFToolsSign</li> <li>edgeXInfraPublish</li> <li>edgeXInfraShipLogs</li> <li>edgeXLTS</li> <li>edgeXNexusPublish</li> <li>edgeXRelease</li> <li>edgeXReleaseDockerImage</li> <li>edgeXReleaseDocs</li> <li>edgeXReleaseGitHubAssets</li> <li>edgeXReleaseGitTag</li> <li>edgeXReleaseGitTagUtil</li> <li>edgeXReleaseOpenApi</li> <li>edgeXReleaseSnap</li> <li>edgeXSemver</li> <li>edgeXSetupEnvironment</li> <li>edgeXSnap</li> <li>edgeXSnyk</li> <li>edgeXSwaggerPublish</li> <li>edgeXUpdateNamedTag</li> <li>edgex</li> </ul>"},{"location":"libraries/edgeXBuildCApp/","title":"edgeXBuildCApp","text":"<p>Shared Library to build C projects</p>"},{"location":"libraries/edgeXBuildCApp/#overview","title":"Overview","text":""},{"location":"libraries/edgeXBuildCApp/#parameters","title":"Parameters","text":"Name Required Type Description and Default Value project required str The name of your project. mavenSettings optional str The maven settings file in Jenkins that has been created for your project. Note the maven settings file specified must exist in Jenkins in order for your project to build.Default: <code>${project}-settings</code> semver optional bool Specify if semantic versioning will be used to version your project. Note edgeX utilizes git-semver for semantic versioning.Default: <code>true</code> testScript optional str The command the build will use to test your project. Note the specified test script will execute in the project's CI build container.Default: <code>make test</code> buildScript optional str The command the build will use to build your project.Default: <code>make build</code> dockerBaseImage optional str The docker base image for your project.Default: <code>nexus3.edgexfoundry.org:10003/edgex-devops/edgex-gcc-base:latest</code> dockerFilePath optional str The path to the Dockerfile for your project.Default: <code>Dockerfile</code> dockerBuildFilePath optional str The path to the Dockerfile that will serve as the CI build image for your project.Default: <code>Dockerfile.build</code> dockerBuildContext optional str The path for Docker to use as its build context when building your project. This applies to building both the CI build image and project image.Default: <code>.</code> dockerBuildImageTarget optional str The name of the docker multi-stage-build stage the pipeline will use when building the CI build image.Default: <code>builder</code> dockerBuildArgs optional list The list of additonal arguments to pass to Docker when building the image for your project.Default: <code>[]</code> dockerNamespace optional str The docker registry namespace to use when publishing Docker images. Note for EdgeX projects images are published to the root of the docker registry and thus the namespace should be empty.Default: <code>''</code> dockerImageName optional str The name of the Docker image for your project.Default: <code>docker-${project}</code> dockerNexusRepo optional str The name of the Docker Nexus repository where the project Docker image <code>dockerImageName</code> will be published to if <code>pushImage</code> is set.Default: <code>staging</code> buildImage optional bool Specify if Jenkins should build a Docker image for your project. Note if false then <code>pushImage</code> will also be set to false.Default: <code>true</code> pushImage optional bool Specify if Jenkins should push your project's image to <code>dockerNexusRepo</code>.Default: <code>true</code> semverBump optional str The semver axis to bump, see git-semver for valid axis values.Default: <code>pre</code> buildSnap optional bool Specify if Jenkins should build a Snap for your project. Note If set, your project must also include a valid snapcraft yaml <code>snap/snapcraft.yaml</code> for Jenkins to attempt to build the Snap.Default: <code>false</code> failureNotify optional str The group emails (comma-delimited) to email when the Jenkins job fails.Default: <code>edgex-tsc-core@lists.edgexfoundry.org,edgex-tsc-devops@lists.edgexfoundry.org</code> arch optional array A list of system architectures to target for the build. Possible values are <code>amd64</code> or <code>arm64</code>.Default: ['amd64', 'arm64']"},{"location":"libraries/edgeXBuildCApp/#usage","title":"Usage","text":""},{"location":"libraries/edgeXBuildCApp/#basic-example","title":"Basic example","text":"<pre><code>edgeXBuildCApp (\n   project: 'device-bacnet-c'\n)\n</code></pre>"},{"location":"libraries/edgeXBuildCApp/#complex-example","title":"Complex example","text":"<pre><code>edgeXBuildCApp (\n    project: 'device-sdk-c',\n    dockerBuildFilePath: 'scripts/Dockerfile.alpine-3.11-base',\n    dockerFilePath: 'scripts/Dockerfile.alpine-3.11',\n    testScript: 'apk add --update --no-cache openssl ca-certificates &amp;&amp; make test',\n    pushImage: false\n)\n</code></pre>"},{"location":"libraries/edgeXBuildCApp/#full-example","title":"Full example","text":"<p>This example shows all the settings that can be specified and their default values.</p> <pre><code>edgeXBuildCApp (\n    project: 'c-project',\n    mavenSettings: 'c-project-settings',\n    semver: true,\n    testScript: 'make test',\n    buildScript: 'make build',\n    dockerBaseImage: 'nexus3.edgexfoundry.org:10003/edgex-devops/edgex-gcc-base:latest',\n    dockerFilePath: 'Dockerfile',\n    dockerBuildFilePath: 'Dockerfile.build',\n    dockerBuildContext: '.',\n    dockerBuildArgs: [],\n    dockerNamespace: '',\n    dockerImageName: 'docker-c-project',\n    dockerNexusRepo: 'staging',\n    buildImage: true,\n    pushImage: true,\n    semverBump: 'pre',\n    buildSnap: false,\n    failureNotify: 'edgex-tsc-core@lists.edgexfoundry.org,edgex-tsc-devops@lists.edgexfoundry.org',\n    arch: ['amd64', 'arm64']\n)\n</code></pre>"},{"location":"libraries/edgeXBuildDocker/","title":"edgeXBuildDocker","text":"<p>Shared Library to build docker images</p>"},{"location":"libraries/edgeXBuildDocker/#overview","title":"Overview","text":""},{"location":"libraries/edgeXBuildDocker/#parameters","title":"Parameters","text":"Name Required Type Description and Default Value project required str The name of your project. mavenSettings optional str The maven settings file in Jenkins that has been created for your project. Note the maven settings file specified must exist in Jenkins in order for your project to build.Default: <code>${project}-settings</code> semver optional bool Specify if semantic versioning will be used to version your project. Note edgeX utilizes git-semver for semantic versioning.Default: <code>true</code> dockerFilePath optional str The path to the Dockerfile for your project.Default: <code>Dockerfile</code> dockerBuildContext optional str The path for Docker to use as its build context when building your project. This applies to building both the CI build image and project image.Default: <code>.</code> dockerBuildArgs optional list The list of additonal arguments to pass to Docker when building the image for your project.Default: <code>[]</code> dockerNamespace optional str The docker registry namespace to use when publishing Docker images. Note for EdgeX projects images are published to the root of the docker registry and thus the namespace should be empty.Default: <code>''</code> dockerImageName optional str The name of the Docker image for your project.Default: <code>docker-${project}</code> dockerTags optional str The tag name for your docker image.Default: <code>[]</code> dockerPushLatest optional str Specify if Jenkins should push the docker image with <code>latest</code> tag. Default: <code>true</code> dockerNexusRepo optional str The name of the Docker Nexus repository where the project Docker image <code>dockerImageName</code> will be published to if <code>pushImage</code> is set.Default: <code>staging</code> pushImage optional bool Specify if Jenkins should push your project's image to <code>dockerNexusRepo</code>.Default: <code>true</code> archiveImage optional bool Specify if the built image need to be archived.Default: <code>false</code> archiveName optional bool The name of the archived image.Default: <code>${_projectName}-archive.tar.gz</code> semverBump optional str The semver axis to bump, see git-semver for valid axis values.Default: <code>pre</code> releaseBranchOverride optional str Specify if you want to override the release branch. failureNotify optional str The group emails (comma-delimited) to email when the Jenkins job fails.Default: <code>edgex-tsc-core@lists.edgexfoundry.org,edgex-tsc-devops@lists.edgexfoundry.org</code> arch optional array A list of system architectures to target for the build. Possible values are <code>amd64</code> or <code>arm64</code>.Default: ['amd64', 'arm64']"},{"location":"libraries/edgeXBuildDocker/#usage","title":"Usage","text":""},{"location":"libraries/edgeXBuildDocker/#basic-example","title":"Basic example","text":"<pre><code>edgeXBuildDocker (\n    project: 'docker-edgex-consul',\n    dockerImageName: 'docker-edgex-consul',\n    semver: true\n)\n</code></pre>"},{"location":"libraries/edgeXBuildDocker/#complex-example","title":"Complex example","text":"<pre><code>edgeXBuildDocker (\n    project: 'edgex-compose',\n    mavenSettings: 'ci-build-images-settings',\n    dockerImageName: 'custom-edgex-compose',\n    dockerNamespace: 'edgex-devops',\n    dockerNexusRepo: 'snapshots',\n    dockerTags: [\"1.24.1\"],\n    releaseBranchOverride: 'edgex-compose'\n)\n</code></pre>"},{"location":"libraries/edgeXBuildDocker/#full-example","title":"Full example","text":"<p>This example shows all the settings that can be specified and their default values.</p> <pre><code>edgeXBuildDocker (\n    project: 'sample-project',\n    mavenSettings: 'sample-project-settings',\n    semver: true,\n    dockerFilePath: 'Dockerfile',\n    dockerBuildContext: '.',\n    dockerBuildArgs: [],\n    dockerNamespace: '',\n    dockerImageName: 'docker-sample-project',\n    dockerTags: [],\n    dockerPushLatest: true,\n    dockerNexusRepo: 'staging',\n    pushImage: true,\n    archiveImage: false,\n    archiveName: sample-project-archive.tar.gz,\n    semverBump: 'pre',\n    releaseBranchOverride: 'golang',\n    failureNotify: 'edgex-tsc-core@lists.edgexfoundry.org,edgex-tsc-devops@lists.edgexfoundry.org',\n    arch: ['amd64', 'arm64']\n)\n</code></pre>"},{"location":"libraries/edgeXBuildGoApp/","title":"edgeXBuildGoApp","text":"<p>Shared Library to build Go projects</p>"},{"location":"libraries/edgeXBuildGoApp/#overview","title":"Overview","text":""},{"location":"libraries/edgeXBuildGoApp/#parameters","title":"Parameters","text":"Name Required Type Description and Default Value project required str The name of your project. mavenSettings optional str The maven settings file in Jenkins that has been created for your project. Note the maven settings file specified must exist in Jenkins in order for your project to build.Default: <code>${project}-settings</code> semver optional bool Specify if semantic versioning will be used to version your project. Note edgeX utilizes git-semver for semantic versioning.Default: <code>true</code> testScript optional str The command the build will use to test your project. Note the specified test script will execute in the project's CI build container.Default: <code>make test</code> buildScript optional str The command the build will use to build your project.Default: <code>make build</code> goVersion optional str The version of Go to use for building the project's CI build image. Note this parameter is used in conjuction with the <code>useAlpineBase</code> parameter to determine the base for the project's CI build image.Default: <code>1.23</code> goProxy optional str The proxy to use when downloading Go modules. The value of this parameter will be set in the <code>GOPROXY</code> environment variable to control the download source of Go modules.Default: <code>https://nexus3.edgexfoundry.org/repository/go-proxy/</code> useAlpineBase optional bool Specify if an Alpine-based <code>edgex-golang-base:${goVersion}-alpine</code> image will be used as the base for the project's CI build image. If true, the respective <code>edgex-golang-base</code> image should exist in the Nexus snapshot repository, if a matching image is not found in Nexus then an Alpine-based <code>go-lang:${goVersion}-alpine</code> DockerHub image will be used. If false, then a non-Alpine <code>go-lang:${goVersion}</code> DockerHub image will be used. Note this parameter is used in conjuction with the <code>goVersion</code> parameter to determine the base for the projects' CI build image.Default: <code>true</code> dockerFilePath optional str The path to the Dockerfile for your project.Default: <code>Dockerfile</code> dockerBuildFilePath optional str The path to the Dockerfile that will serve as the CI build image for your project.Default: <code>Dockerfile.build</code> dockerBuildContext optional str The path for Docker to use as its build context when building your project. This applies to building both the CI build image and project image.Default: <code>.</code> dockerBuildImageTarget optional str The name of the docker multi-stage-build stage the pipeline will use when building the CI build image.Default: <code>builder</code> dockerBuildArgs optional list The list of additonal arguments to pass to Docker when building the image for your project.Default: <code>[]</code> dockerNamespace optional str The docker registry namespace to use when publishing Docker images. Note for EdgeX projects images are published to the root of the docker registry and thus the namespace should be empty.Default: <code>''</code> dockerImageName optional str The name of the Docker image for your project.Default: <code>docker-${project}</code> dockerNexusRepo optional str The name of the Docker Nexus repository where the project Docker image <code>dockerImageName</code> will be published to if <code>pushImage</code> is set.Default: <code>staging</code> buildImage optional bool Specify if Jenkins should build a Docker image for your project. Note if false then <code>pushImage</code> will also be set to false.Default: <code>true</code> pushImage optional bool Specify if Jenkins should push your project's image to <code>dockerNexusRepo</code>.Default: <code>true</code> semverBump optional str The semver axis to bump, see git-semver for valid axis values.Default: <code>pre</code> semverVersion optional str This parameter isn't currently used and will be removed in a future version.Default: <code>''</code> buildSnap optional bool Specify if Jenkins should build a Snap for your project. Note If set, your project must also include a valid snapcraft yaml <code>snap/snapcraft.yaml</code> for Jenkins to attempt to build the Snap.Default: <code>false</code> publishSwaggerDocs optional bool Specify if Jenkins should attempt to publish your projects API documentation to SwaggerHub. Note in order for Jenkins to publish to SwaggerHub you must ensure a valid value for <code>swaggerApiFolders</code> is set.Default: <code>false</code> swaggerApiFolders optional list The list of paths to your projects API Swagger-based documentation.Default: <code>['openapi/v1']</code> failureNotify optional str The group emails (comma-delimited) to email when the Jenkins job fails.Default: <code>edgex-tsc-core@lists.edgexfoundry.org,edgex-tsc-devops@lists.edgexfoundry.org</code> buildExperimentalDockerImage optional bool Specify if Jenkins should add an additonal GitHub tag called <code>experimental</code> at the same commit where the semantic version is tagged. Note this feature is currently only used internally for DevOps builds.Default: <code>false</code> artifactTypes optional list A list of types that the Jenkins build will designate as artifacts, valid list values are <code>docker</code> and <code>archive</code>. Note if <code>archive</code> is specified then all <code>tar.gz</code> or <code>zip</code> files that your project build creates in the <code>artifactRoot</code> folder will be archived to Nexus.Default: <code>['docker']</code> artifactRoot optional str The path in the Jenkins workspace to designate as the artifact root folder. Note all files written to this directory within your build will be automatically pushed to Nexus when the Jenkins job completes.Default: <code>archives/bin</code> arch optional array A list of system architectures to target for the build. Possible values are <code>amd64</code> or <code>arm64</code>.Default: ['amd64', 'arm64']"},{"location":"libraries/edgeXBuildGoApp/#usage","title":"Usage","text":""},{"location":"libraries/edgeXBuildGoApp/#basic-example","title":"Basic example","text":"<pre><code>edgeXBuildGoApp (\n    project: 'device-random-go',\n    goVersion: '1.16'\n)\n</code></pre>"},{"location":"libraries/edgeXBuildGoApp/#complex-example","title":"Complex example","text":"<pre><code>edgeXBuildGoApp (\n    project: 'app-functions-sdk-go',\n    semver: true,\n    goVersion: '1.16',\n    testScript: 'make test',\n    buildImage: false,\n    publishSwaggerDocs: true,\n    swaggerApiFolders: ['openapi']\n)\n</code></pre>"},{"location":"libraries/edgeXBuildGoApp/#full-example","title":"Full example","text":"<p>This example shows all the settings that can be specified and their default values.</p> <pre><code>edgeXBuildGoApp (\n    project: 'go-project',\n    mavenSettings: 'go-project-settings',\n    semver: true,\n    testScript: 'make test',\n    buildScript: 'make build',\n    goVersion: '1.16',\n    goProxy: 'https://nexus3.edgexfoundry.org/repository/go-proxy/',\n    useAlpineBase: true,\n    dockerFilePath: 'Dockerfile',\n    dockerBuildFilePath: 'Dockerfile.build',\n    dockerBuildContext: '.',\n    dockerBuildArgs: [],\n    dockerNamespace: '',\n    dockerImageName: 'docker-go-project',\n    dockerNexusRepo: 'staging',\n    buildImage: true,\n    pushImage: true,\n    semverBump: 'pre',\n    buildSnap: false,\n    publishSwaggerDocs: false,\n    swaggerApiFolders: ['openapi/v1'],\n    failureNotify: 'edgex-tsc-core@lists.edgexfoundry.org,edgex-tsc-devops@lists.edgexfoundry.org',\n    buildExperimentalDockerImage: false,\n    artifactTypes: ['docker'],\n    artifactRoot: 'archives/bin',\n    arch: ['amd64', 'arm64']\n\n)\n</code></pre>"},{"location":"libraries/edgeXBuildGoMod/","title":"edgeXBuildGoMod","text":"<p>Shared Library to build Go projects using Go Modules. It invokes edgeXBuildGoApp with some default parameters.</p>"},{"location":"libraries/edgeXBuildGoMod/#parameters","title":"Parameters","text":"<p>The parameters are similar to shared Library edgeXBuildGoApp with a few exceptions in default values of some parameters. <pre><code>buildImage: false,\npushImage: false,\nsemverBump: 'pre'\n</code></pre> ** Note:** These parameters are not overridable.</p>"},{"location":"libraries/edgeXBuildGoMod/#usage","title":"Usage","text":""},{"location":"libraries/edgeXBuildGoMod/#basic-example","title":"Basic example","text":"<pre><code>edgeXBuildGoMod (\n   project: 'go-mod-configuration'\n)\n</code></pre>"},{"location":"libraries/edgeXBuildGoMod/#full-example","title":"Full example","text":"<p>This example shows all the settings that can be specified and their default values.</p> <pre><code>edgeXBuildGoMod (\n    project: 'go-project',\n    mavenSettings: 'go-project-settings',\n    semver: true,\n    testScript: 'make test',\n    buildScript: 'make build',\n    goVersion: '1.16',\n    goProxy: 'https://nexus3.edgexfoundry.org/repository/go-proxy/',\n    useAlpineBase: true,\n    dockerFilePath: 'Dockerfile',\n    dockerBuildFilePath: 'Dockerfile.build',\n    dockerBuildContext: '.',\n    dockerBuildArgs: [],\n    dockerNamespace: '',\n    dockerImageName: 'docker-go-project',\n    dockerNexusRepo: 'staging',\n    buildImage: false,\n    pushImage: false,\n    semverBump: 'pre',\n    buildSnap: false,\n    publishSwaggerDocs: false,\n    swaggerApiFolders: ['openapi/v1'],\n    failureNotify: 'edgex-tsc-core@lists.edgexfoundry.org,edgex-tsc-devops@lists.edgexfoundry.org',\n    buildExperimentalDockerImage: false,\n    artifactTypes: ['docker'],\n    artifactRoot: 'archives/bin',\n    arch: ['amd64', 'arm64']\n)\n</code></pre>"},{"location":"libraries/edgeXBuildGoParallel/","title":"edgeXBuildGoParallel","text":"<p>Shared Library to build Go projects and Docker images in parallel. Utilizes docker compose --parallel to build Docker images found in the workspace. Currently only used for the edgex-go mono-repo.</p>"},{"location":"libraries/edgeXBuildGoParallel/#overview","title":"Overview","text":""},{"location":"libraries/edgeXBuildGoParallel/#parameters","title":"Parameters","text":"Name Required Type Description and Default Value project required str The name of your project. mavenSettings optional str The maven settings file in Jenkins that has been created for your project. Note the maven settings file specified must exist in Jenkins in order for your project to build.Default: <code>${project}-settings</code> semver optional bool Specify if semantic versioning will be used to version your project. Note edgeX utilizes git-semver for semantic versioning.Default: <code>true</code> testScript optional str The command the build will use to test your project. Note the specified test script will execute in the project's CI build container.Default: <code>make test</code> buildScript optional str The command the build will use to build your project.Default: <code>make build</code> goVersion optional str The version of Go to use for building the project's CI build image. Note this parameter is used in conjuction with the <code>useAlpineBase</code> parameter to determine the base for the project's CI build image.Default: <code>1.23</code> goProxy optional str The proxy to use when downloading Go modules. The value of this parameter will be set in the <code>GOPROXY</code> environment variable to control the download source of Go modules.Default: <code>https://nexus3.edgexfoundry.org/repository/go-proxy/</code> useAlpineBase optional bool Specify if an Alpine-based <code>edgex-golang-base:${goVersion}-alpine</code> image will be used as the base for the project's CI build image. If true, the respective <code>edgex-golang-base</code> image should exist in the Nexus snapshot repository, if a matching image is not found in Nexus then an Alpine-based <code>go-lang:${goVersion}-alpine</code> DockerHub image will be used. If false, then a non-Alpine <code>go-lang:${goVersion}</code> DockerHub image will be used. Note this parameter is used in conjuction with the <code>goVersion</code> parameter to determine the base for the projects' CI build image.Default: <code>true</code> dockerFileGlobPath optional str The pattern for finding Dockerfiles to build. Note Docker images will be named with the same name as the directory which the Dockerfile was found in with a <code>docker-</code> prefix and <code>-go</code> suffix. Example: <code>docker-&lt;folder&gt;-go</code>Default: <code>cmd/** /Dockerfile</code> dockerImageNamePrefix optional str The prefix to apply to the names of all the Docker images built.Default: <code>docker-</code> dockerImageNameSuffix optional str The suffix to apply to the names of all the Docker images built.Default: <code>-go</code> dockerBuildFilePath optional str The path to the Dockerfile that will serve as the CI build image for your project.Default: <code>Dockerfile.build</code> dockerBuildContext optional str The path for Docker to use as its build context when building your project. This applies to building both the CI build image and project image.Default: <code>.</code> dockerBuildImageTarget optional str The name of the docker multi-stage-build stage the pipeline will use when building the CI build image.Default: <code>builder</code> dockerNamespace optional str The docker registry namespace to use when publishing Docker images. Note for EdgeX projects images are published to the root of the docker registry and thus the namespace should be empty.Default: <code>''</code> dockerNexusRepo optional str The name of the Docker Nexus repository where the project Docker images will be published to if <code>pushImage</code> is set.Default: <code>staging</code> buildImage optional bool Specify if Jenkins should build a Docker image for your project. Note if false then <code>pushImage</code> will also be set to falseDefault: <code>true</code> pushImage optional bool Specify if Jenkins should push your project's image to <code>dockerNexusRepo</code>.Default: <code>true</code> semverBump optional str The semver axis to bump, see git-semver for valid axis values.Default: <code>pre</code> buildSnap optional bool Specify if Jenkins should build a Snap for your project. Note If set, your project must also include a valid snapcraft yaml <code>snap/snapcraft.yaml</code> for Jenkins to attempt to build the Snap.Default: <code>false</code> publishSwaggerDocs optional bool Specify if Jenkins should attempt to publish your projects API documentation to SwaggerHub. Note in order for Jenkins to publish to SwaggerHub you must ensure a valid value for <code>swaggerApiFolders</code> is set.Default: <code>false</code> swaggerApiFolders optional list The list of paths to your projects API Swagger-based documentation.Default: <code>['openapi/v1', 'openapi/v2', 'openapi']</code> failureNotify optional str The group emails (comma-delimited) to email when the Jenkins job fails.Default: <code>edgex-tsc-core@lists.edgexfoundry.org,edgex-tsc-devops@lists.edgexfoundry.org</code> arch optional array A list of system architectures to target for the build. Possible values are <code>amd64</code> or <code>arm64</code>.Default: ['amd64', 'arm64']"},{"location":"libraries/edgeXBuildGoParallel/#usage","title":"Usage","text":""},{"location":"libraries/edgeXBuildGoParallel/#basic-example","title":"Basic example","text":"<pre><code>edgeXBuildGoParallel (\n    project: 'edgex-go',\n    dockerFileGlobPath: 'cmd/** /Dockerfile',\n)\n</code></pre>"},{"location":"libraries/edgeXBuildGoParallel/#complex-example","title":"Complex example","text":"<pre><code>edgeXBuildGoParallel(\n   project: 'edgex-go',\n   dockerFileGlobPath: 'cmd/** /Dockerfile',\n   testScript: 'make test',\n   buildScript: 'make build',\n   publishSwaggerDocs: true,\n   swaggerApiFolders: ['openapi/v1', 'openapi/v2', 'openapi'],\n   buildSnap: true\n)\n</code></pre>"},{"location":"libraries/edgeXBuildGoParallel/#full-example","title":"Full example","text":"<p>This example shows all the settings that can be specified and their default values.</p> <pre><code>edgeXBuildGoParallel (\n    project: 'go-project',\n    mavenSettings: 'go-project-settings',\n    semver: true,\n    testScript: 'make test',\n    buildScript: 'make build',\n    goVersion: '1.16',\n    goProxy: 'https://nexus3.edgexfoundry.org/repository/go-proxy/',\n    useAlpineBase: true,\n    dockerFileGlobPath: 'cmd/** /Dockerfile',\n    dockerImageNamePrefix: 'docker-',\n    dockerImageNameSuffix: '-go',\n    dockerBuildFilePath: 'Dockerfile.build',\n    dockerBuildContext: '.',\n    dockerNamespace: '',\n    dockerNexusRepo: 'staging',\n    buildImage: true,\n    pushImage: true,\n    semverBump: 'pre',\n    buildSnap: false,\n    publishSwaggerDocs: false,\n    swaggerApiFolders: ['openapi/v1', 'openapi/v2', 'openapi'],\n    failureNotify: 'edgex-tsc-core@lists.edgexfoundry.org,edgex-tsc-devops@lists.edgexfoundry.org',\n    arch: ['amd64', 'arm64']\n)\n</code></pre>"},{"location":"libraries/edgeXClair/","title":"edgeXClair","text":"<p>\u26a0\ufe0f Deprecated will be removed in a future version. DO NOT USE \u26a0\ufe0f</p> <p>Shared library function to scan docker images for vulnerabilities using Klar. Please use <code>edgeXSnyk</code> instead.</p>"},{"location":"libraries/edgeXCodecov/","title":"edgeXCodecov","text":""},{"location":"libraries/edgeXCodecov/#overview","title":"Overview","text":"<p>Shared library to publish Codecov results to CodeCov.io</p>"},{"location":"libraries/edgeXCodecov/#parameters","title":"Parameters","text":"Name Required Type Description and Default Value tokenFile false str Id of managed config file where token is stored. If <code>null</code> or empty, token file is automatically generated with: <code>${env.PROJECT}-codecov-token</code>"},{"location":"libraries/edgeXCodecov/#usage","title":"Usage","text":"<pre><code>edgeXCodecov('sample-service-codecov-token')\n</code></pre>"},{"location":"libraries/edgeXDocker/","title":"edgeXDocker","text":""},{"location":"libraries/edgeXDocker/#overview","title":"Overview","text":"<p>Shared library that contains convenience functions for interacting with Docker. This shared library contains numerous functions so only a summary will be provided for each given function. If you have further questions about implementation details please refer to the source code.</p>"},{"location":"libraries/edgeXDocker/#functions","title":"Functions:","text":"<ul> <li><code>edgeXDocker.build</code>: Build a docker image from optional <code>baseImage</code> with a set of default: docker build_args, labels, and tags.</li> <li><code>edgeXDocker.buildInParallel</code>: Build multiple docker images in parallel. This technique utilizes docker compose to build multiple images using the parallel flag.</li> <li><code>edgeXDocker.generateDockerComposeForBuild</code>: Supporting function for <code>edgeXDocker.buildInParallel</code> that generates a docker compose file for a given list of docker images.</li> <li><code>edgeXDocker.generateServiceYaml</code>: Supporting function for <code>edgeXDocker.buildInParallel</code> that generates service level yaml for a specific docker image.</li> <li><code>edgeXDocker.push</code>: Push a specific docker image and optionally tag it with the <code>latest</code> tag. A nexus repository can also optionally be specified as well as specific tags.</li> <li><code>edgeXDocker.pushAll</code>: Push all docker images specified in the <code>dockerImages</code> list. To be used in conjunction with the same input format used by <code>edgeXDocker.buildInParallel</code> to push all images.</li> <li><code>edgeXDocker.getDockerTags</code>: Generates the default set of tags used when pushing all edgex docker images with the <code>edgeXDocker.push</code> function.</li> <li><code>edgeXDocker.finalImageName</code>: Prepends a docker image with <code>env.DOCKER_REGISTRY_NAMESPACE</code> if defined.</li> <li><code>edgeXDocker.cleanImageUrl</code>: Returns image url without protocol.</li> <li><code>edgeXDocker.parse</code>: Reads a docker image url and returns the parsed image object components.</li> <li><code>edgeXDocker.toImageStr</code>: Returns docker image string from an image object.</li> </ul>"},{"location":"libraries/edgeXDocker/#parsed-image-object","title":"Parsed image object","text":"<pre><code>[\n   host: hostname if any associated with the image,\n   fullImage: full image name with tag,\n   namespace: namespace of the image if any,\n   image: image name without tag,\n   tag: tag associated with the image if any\n]\n</code></pre>"},{"location":"libraries/edgeXDockerLogin/","title":"edgeXDockerLogin","text":""},{"location":"libraries/edgeXDockerLogin/#overview","title":"Overview","text":"<p>Shared library that wraps the Linux Foundation's (LF) docker login script: <code>./resources/global-jjb/shell/docker-login.sh</code>. </p> <p>The LF Global JJB Docker Login script looks for the following environment variables:  <code>$SETTINGS_FILE</code>, <code>$DOCKER_REGISTRY</code>, <code>$REGISTRY_PORTS</code>, <code>$DOCKERHUB_REGISTRY</code>, <code>$DOCKERHUB_EMAIL</code> which this script automatically sets. Based on given config map entries passed in</p> <p>Please refer to the shell script in global-jjb/shell for the usage.</p>"},{"location":"libraries/edgeXDockerLogin/#parameters","title":"Parameters","text":"Name Required Type Description and Default Value settingsFile true str Config file Id that contains authentication details to docker registries. Unique to each Edgex repository. dockerRegistry false str Override docker registry to login to. dockerRegistryPorts false str Listing of all the registry ports to login to e.g.: <code>10001 10002 10003 10004</code> dockerHubRegistry false str Override docker hub registry. Not commonly used. dockerHubEmail false str Override docker hub email. Not commonly used."},{"location":"libraries/edgeXDockerLogin/#usage","title":"Usage","text":"<pre><code>edgeXDockerLogin(settingsFile: 'edgex-repo-settings')\n</code></pre>"},{"location":"libraries/edgeXEmail/","title":"edgeXEmail","text":""},{"location":"libraries/edgeXEmail/#overview","title":"Overview","text":"<p>Shared library to send build success/fail emails generated by the <code>edgexEmailUtil.generateEmailTemplate</code> function.</p>"},{"location":"libraries/edgeXEmail/#parameters","title":"Parameters","text":"Name Required Type Description and Default Value subject false str Email subject. Default: <code>[${buildStatus}] ${env.JOB_NAME} Build #${env.BUILD_NUMBER}</code> emailTo true str Comma separated list of email address(s) to send email to."},{"location":"libraries/edgeXEmail/#usage","title":"Usage","text":"<pre><code>edgeXEmail(emailTo: 'bob@example.com,susan@example.com')\n</code></pre>"},{"location":"libraries/edgeXEmailUtil/","title":"edgeXEmailUtil","text":""},{"location":"libraries/edgeXEmailUtil/#overview","title":"Overview","text":"<p>Shared library to support the edgeXEmail function by returning relevant build information that can be used to generate an email template. Email template can be found here: https://github.com/edgexfoundry/edgex-global-pipelines/tree/main/resources/email</p>"},{"location":"libraries/edgeXEmailUtil/#function-overview","title":"Function Overview","text":"<ul> <li><code>edgeXEmailUtil.getJobDetailsJson</code>: Extract relevant build details including job information, author, git information, and failure log information and return map of details.</li> <li><code>edgeXEmailUtil.generateEmailTemplate</code>: Generate HTML email template from given job details usually generated by calling <code>edgeXEmailUtil.getJobDetailsJson()</code>. Email templates utilize mustache templates and leverage mustachejs for rendering.</li> </ul>"},{"location":"libraries/edgeXEmailUtil/#usage","title":"Usage","text":"<pre><code>def jobDetails = edgeXEmailUtil.getJobDetailsJson()\ndef emailHtml  = edgeXEmailUtil.generateEmailTemplate(jobDetails)\n\n// do something with emailHtml...\n</code></pre>"},{"location":"libraries/edgeXGHPagesPublish/","title":"edgeXGHPagesPublish","text":""},{"location":"libraries/edgeXGHPagesPublish/#overview","title":"Overview","text":"<p>Shared library to publish html and other resources to a GitHub pages branch off the main repository (typically <code>gh-pages</code>). This shared library is typically used in conjunction with <code>mkdocs</code> and after <code>mkdocs</code> generates all the HTML, etc and the calling pipeline stashes the contents into a specific <code>site-contents</code> Jenkins stash.</p>"},{"location":"libraries/edgeXGHPagesPublish/#process","title":"Process","text":"<p>The typical documentation build process goes like this:</p> <ul> <li>PR is merged into main in upstream repo</li> <li><code>mkdocs</code> is called to generate final documentation in upstream repo job.</li> <li><code>site-contents</code> stash is generated in upstream repo job.</li> <li><code>edgeXGHPagesPublish()</code> is called to publish stash to GitHub pages.</li> </ul>"},{"location":"libraries/edgeXGHPagesPublish/#parameters","title":"Parameters","text":"Name Required Type Description and Default Value repoUrl true str Repo URL where GitHub pages are being published (typically in ssh format for Edgex). credentialId false str Jenkins credentialId used to authenticate to git to push contents. Default: <code>edgex-jenkins-ssh</code> ghPagesBranch false str Git branch where GitHub pages are stored. Default: <code>gh-pages</code> stashName false str Stash name that contains generated site contents that will be published. Default: <code>site-contents</code>"},{"location":"libraries/edgeXGHPagesPublish/#usage","title":"Usage","text":"<pre><code>edgeXGHPagesPublish((repoUrl: 'git@github.com:edgexfoundry/edgex-docs.git')\n</code></pre>"},{"location":"libraries/edgeXGeneric/","title":"edgeXGeneric","text":"<p>\u26a0\ufe0f Deprecated will be removed in a future version. DO NOT USE \u26a0\ufe0f</p> <pre><code>edgeXGeneric([\n    project: 'edgex-go',\n    mavenSettings: ['edgex-go-codecov-token:CODECOV_TOKEN'], (optional)\n    credentials: [string(credentialsId: 'credential-id-here', variable: 'APIKEY')], (optional)\n    env: [\n        GOPATH: '/opt/go-custom/go'\n    ],\n    path: [\n        '/opt/go-custom/go/bin'\n    ],\n    branches: [\n        '*': [\n            pre_build: ['shell/install_custom_golang.sh'],\n            build: [\n                'make test raml_verify &amp;&amp; make build docker',\n                'shell/codecov-uploader.sh'\n            ]\n        ],\n        'main': [\n            post_build: [ 'shell/edgexfoundry-go-docker-push.sh' ]\n        ]\n    ]\n])\n</code></pre>"},{"location":"libraries/edgeXInfraLFToolsSign/","title":"edgeXInfraLFToolsSign","text":""},{"location":"libraries/edgeXInfraLFToolsSign/#overview","title":"Overview","text":"<p>Shared library that wraps signing of git tags or files in a directory using lftools and Sigul. The signing is done inside a docker image managed by the EdgeX DevOps team.</p> <p>Important: Signing git tags, requires the git tag to be an annotated tag. (<code>git tag -a</code>)</p>"},{"location":"libraries/edgeXInfraLFToolsSign/#parameters","title":"Parameters","text":"Name Required Type Description and Default Value sigulConfig false str Config file Id that contains the Sigul config. Default: <code>sigul-config</code> sigulPassword false str Config file Id that contains the Sigul password. Default: <code>sigul-password</code> sigulPKI false str Config file Id that contains the Sigul PKI information. Default: <code>sigul-pki</code> lftoolsImageVersion false str DevOps managed lftools image version tag. Default: <code>0.23.1-centos7</code> command true str Command to run. Valid values: <code>dir, git-tag</code> directory true str Required if command is <code>dir</code>. version true str Required if command is <code>git-tag</code>. mode false str lftools sign mode. Default: <code>parallel</code>"},{"location":"libraries/edgeXInfraLFToolsSign/#usage","title":"Usage","text":"<pre><code>edgeXInfraLFToolsSign(command: 'git-tag', version: 'v2.0.0')\n</code></pre> <pre><code>edgeXInfraLFToolsSign([command: 'dir', directory: 'MyDirectory'])\n</code></pre>"},{"location":"libraries/edgeXInfraPublish/","title":"edgeXInfraPublish","text":""},{"location":"libraries/edgeXInfraPublish/#overview","title":"Overview","text":"<p>Shared library used as a post build stage to publish build artifacts, logs, metrics to EdgeX Nexus server.</p>"},{"location":"libraries/edgeXInfraPublish/#parameters","title":"Parameters","text":"Name Required Type Description and Default Value logSettingsFile false str Config file id for settings to authenticate to Nexus to publish build logs. Default: <code>jenkins-log-archives-settings</code> dockerOptimized false str Whether or not to use a docker image when publishing to Nexus. Default: <code>true</code>"},{"location":"libraries/edgeXInfraPublish/#usage","title":"Usage","text":"<pre><code>edgeXInfraPublish()\n</code></pre> <pre><code>edgeXInfraPublish {\n    logSettingsFile = 'custom-jenkins-log-archives-settings'\n    dockerOptimized = false\n}\n</code></pre>"},{"location":"libraries/edgeXInfraShipLogs/","title":"edgeXInfraPublish","text":"<p>\u26a0\ufe0f Deprecated no longer in use. This has been replace by lfInfraShipLogs. DO NOT USE \u26a0\ufe0f</p>"},{"location":"libraries/edgeXLTS/","title":"edgeXLTS","text":""},{"location":"libraries/edgeXLTS/#overview","title":"Overview","text":"<p>Shared library with helper functions to manage LTS releases. Used as part of the edgeXRelease.groovy pipeline.</p>"},{"location":"libraries/edgeXLTS/#functions","title":"Functions:","text":"<ul> <li><code>edgeXLTS.prepLTS</code>: Prepares a repository for an LTS release. If the repository is Golang based, go vendoring is enabled to support LTS releases.</li> <li><code>edgeXLTS.getLatestLTSCommitId</code>: Retrieves the latest LTS commit sha from a repository.</li> <li><code>edgeXLTS.generateLTSCommitMessage</code>: Creates a an LTS commit message for a release.</li> <li><code>edgeXLTS.prepGoProject</code>: Prepares a Golang based project for an LTS release enable vendoring and removing the <code>vendor</code> directory from the gitignore file.</li> </ul>"},{"location":"libraries/edgeXNexusPublish/","title":"edgeXNexusPublish","text":""},{"location":"libraries/edgeXNexusPublish/#overview","title":"Overview","text":"<p>Shared library to publish a ZIP file to a specific nexus repo.</p>"},{"location":"libraries/edgeXNexusPublish/#parameters","title":"Parameters","text":"Name Required Type Description and Default Value serverId true str Used to lookup credentials in mavenSettings file. Example: <code>logs</code>, <code>docker</code>, <code>nexus.edgexfoundry.org</code> mavenSettings true str Config file Id to use publish to Nexus. Example: <code>log-settings</code> nexusRepo true str The nexus repository name where you would like to publish your artifacts. nexusPath false str Path on the nexus server where file should be stored. Default:<code>${env.SILO}/${env.JENKINS_HOSTNAME}/${env.JOB_NAME}/${env.BUILD_NUMBER}</code> zipFilePath true str path to ZIP file, typically in the workspace."},{"location":"libraries/edgeXNexusPublish/#usage","title":"Usage","text":"<pre><code>edgeXNexusPublish([serverId: 'logs', mavenSettings: 'log-settings', nexusRepo: 'logs', zipFilePath: '*.zip'])\n</code></pre>"},{"location":"libraries/edgeXRelease/","title":"edgeXRelease","text":""},{"location":"libraries/edgeXRelease/#overview","title":"Overview","text":"<p>Shared library with helper functions to manage releases. This is the main entry point for all automated releases using the \ud83d\udd17 cd-management/release repository.</p>"},{"location":"libraries/edgeXRelease/#required-yaml","title":"Required Yaml","text":"Name Required Type Description and Default Value name true str Name of the repository that is being released. version true str Semver version to be released. releaseName true str The codename of the release. This is usually used by sub release processes for naming. releaseStream true str What branch the release is being generated from. (This has been superseded by commitId) commitId true str Git Commit SHA to tag or branch for the release. repo true str https git repository url. Example: <code>https://github.com/edgexfoundry/&lt;repo&gt;.git</code>"},{"location":"libraries/edgeXRelease/#functions","title":"Functions","text":"<ul> <li><code>edgeXRelease.collectReleaseYamlFiles</code>: Search through a provided file path and find all the release yaml files to process and parses yaml into a Groovy object using the <code>readYaml</code> function. Default file pattern to search for will be: <code>release/*.yaml</code>. This function will also validate what files have changed in the commit using <code>edgex.didChange</code> and will only release what was changed.</li> <li><code>edgeXRelease.parallelStepFactory</code>: Returns a Closure to execute the release for all release yaml entries found for the specific commit.</li> <li><code>edgeXRelease.parallelStepFactoryTransform</code>: Transforms release yaml Groovy object into a Groovy Closure containing all the logic needed to perform the release for the specific repository.</li> <li><code>edgeXRelease.stageArtifact</code>: If release contains binaries rather than docker images, the binaries need to be staged before the release occurs. This function forces a build of the artifact by triggering the job using the <code>build(job: ..)</code> Jenkins function.</li> <li><code>edgeXRelease.getBuilderImagesFromReleasedImages</code>: Used to determine what static builder image to use when building a LTS C based repository. Below you can see the transformation.   <pre><code> // Given the release of the following 2 docker images:\n edgeXRelease.getBuilderImagesFromReleasedImages('nexus3.edgexfoundry.org:10004/sample-service-c')\n &gt; nexus3.edgexfoundry.org:10002/sample-service-c-builder-x86_64:jakarta\n\n edgeXRelease.getBuilderImagesFromReleasedImages('nexus3.edgexfoundry.org:10004/sample-service-c-arm64')\n &gt; nexus3.edgexfoundry.org:10002/sample-service-c-builder-arm64:jakarta\n</code></pre></li> </ul>"},{"location":"libraries/edgeXReleaseDockerImage/","title":"edgeXReleaseDockerImage","text":""},{"location":"libraries/edgeXReleaseDockerImage/#overview","title":"Overview","text":"<p>Shared library with helper functions to manage docker image releases to Nexus release and DockerHub.</p>"},{"location":"libraries/edgeXReleaseDockerImage/#required-yaml","title":"Required Yaml","text":"Name Required Type Description and Default Value dockerImage true str Determines whether or not to trigger this function. docker true array Array of docker images to release. docker.image true str Docker image that is being release. docker.destination true array Array of destination registries where to release the image to."},{"location":"libraries/edgeXReleaseDockerImage/#functions","title":"Functions","text":"<ul> <li><code>edgeXReleaseDockerImage.getAvaliableTargets</code>: Returns a list of valid release registries.</li> <li><code>edgeXReleaseDockerImage.isValidReleaseRegistry</code>: Validates registry to ensure we are not pushing images to unknown registries.</li> <li><code>edgeXReleaseDockerImage.publishDockerImages</code>: Iterates through all release registry targets and pushes images based on validating image exists.</li> <li><code>edgeXReleaseDockerImage.publishDockerImage</code>: Pulls, re-tags and pushes source image to destination registry.</li> <li><code>edgeXReleaseDockerImage.validate</code>: Validates release yaml input before any automation is run.</li> <li><code>edgeXReleaseDockerImage.imageExists</code>: Checks docker registry to see if image exists.</li> </ul>"},{"location":"libraries/edgeXReleaseDockerImage/#usage","title":"Usage","text":""},{"location":"libraries/edgeXReleaseDockerImage/#sample-release-yaml","title":"Sample Release Yaml","text":"<pre><code>version: 1.1.2\nreleaseStream: main\ndockerImage: true\ndocker:\n  - image: nexus3.edgexfoundry.org:10004/sample-service\n    destination:\n      - nexus3.edgexfoundry.org:10002/sample-service\n      - docker.io/edgexfoundry/sample-service\n  - image: nexus3.edgexfoundry.org:10004/sample-service-arm64\n    destination:\n      - nexus3.edgexfoundry.org:10002/sample-service-arm64\n      - docker.io/edgexfoundry/sample-service-arm64\n</code></pre>"},{"location":"libraries/edgeXReleaseDockerImage/#groovy-call","title":"Groovy Call","text":"<pre><code>edgeXReleaseDockerImage(releaseYaml)\n</code></pre>"},{"location":"libraries/edgeXReleaseDocs/","title":"edgeXReleaseDocs","text":""},{"location":"libraries/edgeXReleaseDocs/#overview","title":"Overview","text":"<p>Shared library with helper functions to manage documentation releases. Currently used by edgex-docs.</p>"},{"location":"libraries/edgeXReleaseDocs/#required-yaml","title":"Required Yaml","text":"Name Required Type Description and Default Value docs true str Determines whether or not to trigger this function. docsInfo.nextReleaseVersion true str Next release version to add to the documentation. docsInfo.nextReleaseName true str Next release name to add to the documentation. docsInfo.reviewers true str Who to assign the generated PR's to."},{"location":"libraries/edgeXReleaseDocs/#functions","title":"Functions","text":"<ul> <li><code>edgeXReleaseDocs.publishReleaseBranch</code>: Makes release branch related changes in unique branch then commits release branch.</li> <li><code>edgeXReleaseDocs.publishVersionChangesPR</code>: Makes version file related changes in unique branch then commits and opens PR.</li> <li><code>edgeXReleaseDocs.validate</code>: Validates release yaml input before any automation is run.</li> </ul>"},{"location":"libraries/edgeXReleaseDocs/#usage","title":"Usage","text":""},{"location":"libraries/edgeXReleaseDocs/#sample-release-yaml","title":"Sample Release Yaml","text":"<pre><code>name: 'edgex-docs'\nversion: '2.2.0'\nreleaseName: 'kamakura'\nreleaseStream: 'main'\nrepo: 'https://github.com/edgexfoundry/edgex-docs.git'\ncommitId: 'c72b16708d6eed9a08be464a432ce22db7d90667'\ngitTag: false\ndockerImages: false\ndocs: true\ndocsInfo:\n  nextReleaseVersion: \"2.3.0\"\n  nextReleaseName: levski\n  reviewers: edgex-docs-committers\n</code></pre>"},{"location":"libraries/edgeXReleaseDocs/#groovy-call","title":"Groovy Call","text":"<pre><code>edgeXReleaseDocs(releaseYaml)\n</code></pre>"},{"location":"libraries/edgeXReleaseGitHubAssets/","title":"edgeXReleaseGitHubAssets","text":""},{"location":"libraries/edgeXReleaseGitHubAssets/#overview","title":"Overview","text":"<p>Shared library with helper functions to manage GitHub Releases with attached binaries. This function works in conjunction with the docker image generated from \ud83d\udd17 Create GitHub Release to manage GitHub releases. Currently used by edgex-cli.</p>"},{"location":"libraries/edgeXReleaseGitHubAssets/#required-yaml","title":"Required Yaml","text":"Name Required Type Description and Default Value gitHubRelease true str Determines whether or not to trigger this function. gitHubReleaseAssets true array List of binaries to release along with generated GitHub Release."},{"location":"libraries/edgeXReleaseGitHubAssets/#functions","title":"Functions","text":"<ul> <li><code>edgeXReleaseGitHubAssets.getCredentialsId</code>: Return correct PAT based on ENV.SILO to access GitHub api.</li> <li><code>edgeXReleaseGitHubAssets.getRepoInfo</code>: Extracts pertinent information from repository and returns as Map.</li> <li><code>edgeXReleaseGitHubAssets.createGitHubRelease</code>: Wraps call to <code>create-github-release</code> to generate GitHub release.</li> <li><code>edgeXReleaseGitHubAssets.validate</code>: Validates release yaml input before any automation is run.</li> </ul>"},{"location":"libraries/edgeXReleaseGitHubAssets/#usage","title":"Usage","text":""},{"location":"libraries/edgeXReleaseGitHubAssets/#sample-release-yaml","title":"Sample Release Yaml","text":"<pre><code>name: 'sample-service'\nversion: 1.1.2\nreleaseStream: 'main'\nrepo: 'https://github.com/edgexfoundry/sample-service.git'\ngitHubRelease: true\ngitHubReleaseAssets:\n  - 'https://nexus-location/asset1'\n  - 'https://nexus-location/asset2'\n  - 'https://nexus-location/asset3'\n</code></pre>"},{"location":"libraries/edgeXReleaseGitHubAssets/#groovy-call","title":"Groovy Call","text":"<pre><code>edgeXReleaseGitHubAssets(releaseYaml)\n</code></pre>"},{"location":"libraries/edgeXReleaseGitTag/","title":"edgeXReleaseGitHubTag","text":""},{"location":"libraries/edgeXReleaseGitTag/#overview","title":"Overview","text":"<p>Shared library with helper functions to create, sign and bump Git tags.</p>"},{"location":"libraries/edgeXReleaseGitTag/#required-yaml","title":"Required Yaml","text":"Name Required Type Description and Default Value gitTag true str Determines whether or not to trigger this function. semverBumpLevel false str Semver bump level to be used by git-semver. Default: <code>-pre=dev pre</code>"},{"location":"libraries/edgeXReleaseGitTag/#functions","title":"Functions","text":"<ul> <li><code>edgeXReleaseGitHubTag.cloneRepo</code>: Generic function to properly clone a repository to a specific subfolder. Directory name generated from <code>releaseYaml.name</code>.</li> <li><code>edgeXReleaseGitHubTag.setAndSignGitTag</code>: Sets up release tag using git-semver from the specified version set in <code>releaseYaml.version</code>. NOTE: git-semver force is used here for impotency in case tag already exists. So existing tags will be overridden.</li> <li><code>edgeXReleaseGitHubTag.bumpAndPushGitTag</code>: Pushes signed tag and optionally bumps next version.</li> </ul>"},{"location":"libraries/edgeXReleaseGitTag/#usage","title":"Usage","text":""},{"location":"libraries/edgeXReleaseGitTag/#sample-release-yaml","title":"Sample Release Yaml","text":"<pre><code>name: 'sample-service'\nversion: '1.1.2'\nreleaseStream: 'main'\ncommitId: '0cc1d67607642c9413e4a80d25a2df35ecc76d41'\nrepo: 'https://github.com/edgexfoundry/sample-service.git'\ngitTag: true\nsemverBumpLevel: 'patch' #optional\n</code></pre>"},{"location":"libraries/edgeXReleaseGitTag/#groovy-call","title":"Groovy Call","text":"<pre><code>edgeXReleaseGitTag(releaseYaml)\n</code></pre>"},{"location":"libraries/edgeXReleaseGitTagUtil/","title":"edgeXReleaseGitHubTagUtil","text":""},{"location":"libraries/edgeXReleaseGitTagUtil/#overview","title":"Overview","text":"<p>Shared library with supporting helper functions to manage Git tags.</p>"},{"location":"libraries/edgeXReleaseGitTagUtil/#functions","title":"Functions","text":"<ul> <li><code>edgeXReleaseGitHubTagUtil.getSSHRepoName</code>: Converts <code>https</code> repo remote to ssh <code>git@github.com:</code> remote.</li> <li><code>edgeXReleaseGitHubTagUtil.signGitTag</code>: Wrapper around <code>edgeXInfraLFToolsSign</code> that signs git tag for a release.</li> <li><code>edgeXReleaseGitHubTagUtil.releaseGitTag</code>: Main function that does full end-to-end git tag release.</li> <li><code>edgeXReleaseGitHubTagUtil.validate</code>: Validates release yaml input before any automation is run.</li> </ul>"},{"location":"libraries/edgeXReleaseOpenApi/","title":"edgeXReleaseOpenApi","text":""},{"location":"libraries/edgeXReleaseOpenApi/#overview","title":"Overview","text":"<p>Shared library with helper functions to manage OpenAPI YAML related changes. Currently used by sdk repos.</p>"},{"location":"libraries/edgeXReleaseOpenApi/#required-yaml","title":"Required Yaml","text":"Name Required Type Description and Default Value apiInfo.nextReleaseVersion true str Next release version to for the OpenAPI yaml files. apiInfo.reviewers true str Who to assign the generated PR to."},{"location":"libraries/edgeXReleaseOpenApi/#functions","title":"Functions","text":"<ul> <li><code>edgeXReleaseOpenApi.publishReleaseBranch</code>: Makes release branch related changes in unique branch then commits release branch.</li> <li><code>edgeXReleaseOpenApi.publishOpenApiChanges</code>: Makes OpenAPI related changes in unique branch then commits and opens PR.</li> <li><code>edgeXReleaseOpenApi.validate</code>: Validates release yaml input before any automation is run.</li> </ul>"},{"location":"libraries/edgeXReleaseOpenApi/#usage","title":"Usage","text":""},{"location":"libraries/edgeXReleaseOpenApi/#sample-release-yaml","title":"Sample Release Yaml","text":"<pre><code>name: 'device-sdk-go'\nversion: '2.2.0'\nreleaseName: 'kamakura'\nreleaseStream: 'main'\nrepo: 'https://github.com/edgexfoundry/device-sdk-go.git'\ncommitId: 'c72b16708d6eed9a08be464a432ce22db7d90667'\ngitTag: true\ndockerImages: false\ngitHubRelease: false\napiInfo: [\n   nextReleaseVersion: '2.3.0',\n   reviewers: edgexfoundry/edgex-committers\n]\n</code></pre>"},{"location":"libraries/edgeXReleaseOpenApi/#groovy-call","title":"Groovy Call","text":"<pre><code>edgeXReleaseOpenApi(releaseYaml)\n</code></pre>"},{"location":"libraries/edgeXReleaseSnap/","title":"edgeXReleaseSnap","text":"<p>\u26a0\ufe0f Deprecated... Snaps are no longer published by EdgeX DevOps. They are now managed by the team at Canonical. DO NOT USE \u26a0\ufe0f</p>"},{"location":"libraries/edgeXSemver/","title":"edgeXSemver","text":""},{"location":"libraries/edgeXSemver/#overview","title":"Overview","text":"<p>Shared library containing a useful set of functions to help with the creation of semantic versioning using the git-semver python library. The main call function builds the <code>git semver</code> command based on the provided input.</p> <p>Please note: this shared library is responsible for setting the <code>VERSION</code> environment variable during <code>git semver init</code> execution.</p>"},{"location":"libraries/edgeXSemver/#parameters","title":"Parameters","text":"Name Required Type Description and Default Value command false str Specify which git semver sub command to run. Example: <code>init</code>, <code>bump</code>, <code>push</code> semverVersion false string Force a specific override version instead of reading the version from the semver branch. Default: <code>&lt;empty string&gt;</code> gitSemverVersion false string What version of the git-semver docker image to use. Default: <code>latest</code> credentials false string Which Jenkins credential to use to authenticate to GitHub and push git tag. Default: <code>edgex-jenkins-ssh</code>"},{"location":"libraries/edgeXSemver/#functions","title":"Functions","text":"<ul> <li><code>edgeXSemver.executeGitSemver</code>: Execute semverCommand via ssh with provided credentials.</li> <li><code>edgeXSemver.setGitSemverHeadTag</code>: set <code>GITSEMVER_HEAD_TAG</code> to value of <code>HEAD</code> when any of the following conditions are satisfied:</li> <li>An init version is specified and HEAD is tagged with init version.</li> <li>An init version is not specified and HEAD is tagged.</li> <li><code>edgeXSemver.getCommitTags</code>: Return list of all tags at a specific commit point.</li> </ul>"},{"location":"libraries/edgeXSemver/#usage","title":"Usage","text":"<p>Regular init</p> <pre><code>edgeXSemver('init')\n</code></pre> <p>Force specific the semver version to use.</p> <pre><code>edgeXSemver('init', '2.0.0')\n</code></pre> <p>Bump the semver version using default semver bump level (pre-release).</p> <pre><code>edgeXSemver('bump')\n</code></pre>"},{"location":"libraries/edgeXSetupEnvironment/","title":"edgeXSetupEnvironment","text":""},{"location":"libraries/edgeXSetupEnvironment/#overview","title":"Overview","text":"<p>Shared library to setup a build environment given a Map of key value pairs. Some extra environment variables are set to help with the build process including:</p> <ul> <li><code>GIT_BRANCH</code></li> <li><code>GIT_COMMIT</code></li> <li><code>GIT_BRANCH_CLEAN</code></li> <li><code>SHORT_GIT_COMMIT</code></li> <li><code>SEMVER_BRANCH</code></li> <li><code>SEMVER_PRE_PREFIX</code></li> </ul>"},{"location":"libraries/edgeXSetupEnvironment/#parameters","title":"Parameters","text":"Name Required Type Description and Default Value vars false str A Map of key/value pairs to expose to the Jenkins environment."},{"location":"libraries/edgeXSetupEnvironment/#usage","title":"Usage","text":"<pre><code>edgeXSetupEnvironment([ PROJECT: 'edgex-global-pipelines' ])\n...\n...\n// This will expose an environment variable named `PROJECT` with the value `edgex-global-pipelines`\n// as well as the extra environment vars mentioned above.\n</code></pre>"},{"location":"libraries/edgeXSnap/","title":"edgeXSnap","text":""},{"location":"libraries/edgeXSnap/#overview","title":"Overview","text":"<p>\u26a0\ufe0f Deprecated Warning... Snaps are no longer being built as part of the Jenkins pipeline. They are being built and tested using GitHub Actions and are managed by the team at Canonical. DO NOT USE \u26a0\ufe0f</p> <p>Wrapper around resources/snap-build.sh script. No parameters required.</p>"},{"location":"libraries/edgeXSnap/#usage","title":"Usage","text":"<pre><code>edgeXSnap()\n</code></pre>"},{"location":"libraries/edgeXSnyk/","title":"edgeXSnyk","text":""},{"location":"libraries/edgeXSnyk/#overview","title":"Overview","text":"<p>Shared library containing a useful set of functions to help with the creation of semantic versioning using the git-semver python library. The main call function builds the <code>git semver</code> command based on the provided input.</p> <p>Please note: this shared library is responsible for setting the <code>VERSION</code> environment variable during <code>git semver init</code> execution.</p>"},{"location":"libraries/edgeXSnyk/#parameters","title":"Parameters","text":"Name Required Type Description and Default Value command false str Specify which Snyk command to run. Possible values: <code>test</code>, <code>monitor</code>. Default: <code>monitor</code> dockerImage false string If scanning a docker image either a local image name or remote image name. dockerFile false string If scanning a docker image, the path to <code>Dockerfile</code> relative to the Jenkins <code>WORKSPACE</code>. severity false string Severity threshold to mark the build as <code>unstable</code>. sendEmail false string Whether or not to send an email of the findings. Default: <code>true</code> emailTo false string Recipient list of who to send the email to. htmlReport false string Whether or not to generate an HTML report of findings. Default: <code>false</code>"},{"location":"libraries/edgeXSnyk/#usage","title":"Usage","text":"<p>Test and continuously monitor project dependencies. For Go projects, this is typically the <code>go.mod</code> file:</p> <pre><code>edgeXSnyk()\n</code></pre> <p>Test docker image for vulnerabilities and output results to Jenkins console:</p> <pre><code>edgeXSnyk(\n   command: 'test',\n   dockerImage: 'nexus3.edgexfoundry.org:10004/core-command:latest',\n   dockerFile: '&lt;path to Dockerfile&gt;'\n)\n</code></pre> <p>Test docker image for vulnerabilities and send email of findings:</p> <pre><code>edgeXSnyk(\n   command: 'test',\n   dockerImage: 'nexus3.edgexfoundry.org:10004/core-command:latest',\n   dockerFile: '&lt;path to Dockerfile&gt;',\n   severity: 'high',\n   sendEmail: true,\n   emailTo: &lt;email address(s)&gt;,\n   htmlReport: true\n)\n</code></pre>"},{"location":"libraries/edgeXSwaggerPublish/","title":"edgeXSwaggerPublish","text":""},{"location":"libraries/edgeXSwaggerPublish/#overview","title":"Overview","text":"<p>Shared library containing methods to publish Swagger API docs up to https://api.swaggerhub.com.</p> <p>NOTE: <code>${APIKEY}</code> needs to be a pointer to a file with the key. This will need to be set locally from your environment or from Jenkins.</p>"},{"location":"libraries/edgeXSwaggerPublish/#parameters","title":"Parameters","text":"Name Required Type Description and Default Value owner false str Specify Swagger API owner. Default: <code>EdgeXFoundry1</code> apiFolders true string Space delimited list of folders to publish. swaggerCredentialId false string Config file Id that contains the Swagger API key to allow publishing of API docs. Default: <code>swaggerhub-api-key</code>"},{"location":"libraries/edgeXSwaggerPublish/#usage","title":"Usage","text":"<p>Publish single folder to Swagger to owner:EdgeXFoundry1</p> <pre><code>edgeXSwaggerPublish(apiFolders: 'openapi/v1')\n</code></pre> <p>Publish multiple API folders to Swagger to owner:EdgeXFoundry1</p> <pre><code>edgeXSwaggerPublish(apiFolders: 'openapi/v1 openapi/v2')\n</code></pre> <p>Publish single folder to swagger with a customer owner/organization.</p> <pre><code>edgeXSwaggerPublish(owner: 'customOwner', apiFolders:'openapi/v1')\n</code></pre>"},{"location":"libraries/edgeXUpdateNamedTag/","title":"edgeXUpdateNamedTag","text":""},{"location":"libraries/edgeXUpdateNamedTag/#overview","title":"Overview","text":"<p>Shared library that wraps the resources/update-named-tag.sh script. This script will create a new \"named\" git tag pointing to an existing  git tag. This is really useful for creating \"stable\" or \"experimental\" tags that point to another specific versioned git tag. For example, if you wanted to have a \"stable\" tag point to a version tag of \"v1.4.0\" you can run this script to do so. See usage below.</p>"},{"location":"libraries/edgeXUpdateNamedTag/#parameters","title":"Parameters","text":"Name Required Type Description and Default Value ogVersion true str Original version to create named tag from. namedVersion true str Space delimited list of folders to publish."},{"location":"libraries/edgeXUpdateNamedTag/#usage","title":"Usage","text":"<p>Create a <code>stable</code> tag pointing to a specific version.</p> <pre><code>edgeXUpdateNamedTag('v1.2.3', 'stable')\n</code></pre> <p>Create an <code>experimental</code> tag pointing to a specific version.</p> <pre><code>edgeXUpdateNamedTag('v2.1.20', 'experimental')\n</code></pre>"},{"location":"libraries/edgex/","title":"edgex","text":""},{"location":"libraries/edgex/#overview","title":"Overview","text":"<p>Shared library of common helper functions for all EdgeX Jenkins pipelines.</p>"},{"location":"libraries/edgex/#functions","title":"Functions","text":"<ul> <li><code>edgex.isReleaseStream</code>: Used to validate whether the current branch that Jenkins is building is a branch that is considered a branch with \"releasable\" artifacts (i.e docker push, git semver push).</li> <li><code>edgex.isLTS</code>: Used to determine if the current branch that Jenkins is building is for an LTS release.</li> <li><code>edgex.getTargetBranch</code>: Used to determine the target branch that is being merged into for a PR.</li> <li><code>edgex.didChange</code>: Determine if the given expression matches the files that changed in a given PR or merge. For example:    <pre><code>// Did any .go files change from the current branch compared to origin/main\ndidChange('*.go')\n\n// Did any .yaml files change from the current branch compared to origin/release\ndidChange('*.yaml', 'origin/release')\n</code></pre></li> <li><code>edgex.mainNode</code>: Given a config map with <code>config.nodes</code>, either return the node label marked as <code>defaultNode = true</code> or return the DevOps managed \"default\" node label.</li> <li><code>edgex.nodeExists</code>: Verify a given node architecture matches provided architecture.</li> <li><code>edgex.getNode</code>: Return node with architecture that matches provided architecture.</li> <li><code>edgex.setupNodes</code>: Setup default node labels for x86_64 and arm64 nodes.</li> <li><code>edgex.getVmArch</code>: Run uname to determine VM architecture. If <code>aarch64</code> is returned, convert to the result to <code>arm64</code>.</li> <li><code>edgex.bannerMessage</code>: Vanity function to wrap given input message with a banner style output for easier readability in Jenkins console.</li> <li><code>edgex.printMap</code>: Vanity function to print Groovy Map to the Jenkins console.</li> <li><code>edgex.defaultTrue</code>: Returns true if the input is <code>true</code> or <code>null</code>. This is useful to setup default values in functions when none is provided.</li> <li><code>edgex.defaultFalse</code>: Returns true if the input is <code>false</code> or <code>null</code>. This is useful to setup default values in functions when none is provided.</li> <li><code>edgex.releaseInfo</code>: Call shell script <code>resources/releaseinfo.sh</code> to output current edgex-global-pipeline version information in the Jenkins console. This is really useful for debugging older builds in case issues are discovered.</li> <li><code>edgex.isDryRun</code>: Whether or not the <code>env.DRY_RUN</code> environment variable is set. Will return <code>true</code> if DRY_RUN is set, <code>false</code> otherwise.</li> <li><code>edgex.isMergeCommit</code>: Determines if the current commit Jenkins is building is considered a git \"merge commit\". Useful if determining parent commit info.</li> <li><code>edgex.getPreviousCommit</code>: Determines the previous commit SHA given the merge commit or squash commit git use-cases. Different git commands have to be run to be able to determine the previous commit.</li> <li><code>edgex.getBranchName</code>: Returns the current branch name from git.</li> <li><code>edgex.getCommitMessage</code>: Returns the current commit message from git given a commit SHA.</li> <li><code>edgex.isBuildCommit</code>: Return true when the commit message follows the pattern <code>build(...): [semanticVersion,namedTag] ...</code>.</li> <li><code>edgex.parseBuildCommit</code>: Return the parameters for the build <code>[semanticVersion,namedTag]</code>.</li> <li><code>edgex.getTmpDir</code>: Run <code>mktemp</code> with given pattern to create a temporary directory in <code>/tmp</code>.</li> <li><code>edgex.getGoLangBaseImage</code>: Return DevOps managed base images used in Go pipelines.</li> <li><code>edgex.isGoProject</code>: Looks at repository directory structure to determine if the repository is Golang based. Uses the existence of the <code>go.mod</code> file.</li> <li><code>edgex.getCBaseImage</code>: Return the base image used as the base image for all C based repositories.</li> <li><code>edgex.parallelJobCost</code>: Wraps call to <code>lfParallelCostCapture</code> inside docker image to save time downloading pip dependencies.</li> <li><code>edgex.patchAlpineSeccompArm64</code>: A fix for arm64 nodes that enables a security profile for docker. Another workaround is to just use the <code>--privileged</code> docker flag.</li> <li><code>edgex.isLTSReleaseBuild</code>: Returns <code>true</code> if current commit message begins with <code>ci(lts-release)</code>.</li> <li><code>edgex.semverPrep</code>: Poorly named function that sets up the <code>env.NAMED_TAG</code> and <code>env.BUILD_STABLE_DOCKER_IMAGE</code> for the build commit concept. Will be removed in a future release.</li> <li><code>edgex.waitFor</code>: Useful function to wait for a condition in a shell script to be met.</li> <li><code>edgex.waitForImages</code>: Useful function to determine if a docker image has been pushed to a repository.</li> <li><code>edgex.commitChange</code>: Commits a change to the repo with a given message.</li> <li><code>edgex.createPR</code>: Creates a PR with the GitHub CLI for with a given branch, title, message and reviewers for. Note: This is generic enough to be used in other functions.</li> </ul>"},{"location":"releases/jakarta-lts-initial/","title":"Jakarta LTS Changes","text":""},{"location":"releases/jakarta-lts-initial/#cd-management","title":"cd-management","text":"<ul> <li>New <code>release</code> branch in cd-management to manage lts. Maybe call it <code>lts</code></li> <li>New field in YAML signifying that this is an LTS release:</li> </ul> <pre><code>---\nname: 'edgex-go'\nversion: '2.1.0'\nreleaseName: 'jakarta'\nreleaseStream: 'main'\nlts: true # &lt;-- new field\n...\n</code></pre>"},{"location":"releases/jakarta-lts-initial/#questions","title":"Questions?","text":"<ul> <li>Should we name the lts branch for all repos <code>lts</code>? OR use it's codename like <code>jakarta</code>?</li> </ul> <p>This would trigger a new process in edgex-global-pipelines@edgeXRelease. See changes to edgex-global-pipelines</p>"},{"location":"releases/jakarta-lts-initial/#ci-build-images","title":"ci-build-images","text":"<ul> <li>Branch the <code>golang-1.16</code> branch to <code>golang-1.16-lts</code> or similar and push the resulting image to the Nexus release repo.</li> <li>Branch the <code>gcc</code> branch to <code>gcc-lts</code> or similar and push the resulting image to the Nexus release repo.</li> </ul> <p>These images should be pretty simple as to push to Nexus release because edgeXBuildDocker allows us to specify the Nexus release repository as a target. See <code>dockerNexusRepo</code> in the docs.</p>"},{"location":"releases/jakarta-lts-initial/#edgex-compose","title":"edgex-compose","text":"<p>3rd party docker images should be archive to the Nexus release repository. Images that should be archived are:</p> <p>consul kong lfedge/ekuiper postgres redis vault</p> <p>A modification to the Jenkinsfile can be make to introduce a new pipeline parameter to trigger a stage that gathers the existing 3rd party images, retags and pushes them to the Nexus release repository.</p> <p>Sample script to extract and retag:</p> <pre><code>for image in $(grep \"image:\" ./docker-compose.yml | grep -v nexus | awk '{print $2}' | sort); do echo docker tag $image nexus3.edgexfoundry.org:10002/3rdparty/$image; echo docker push nexus3.edgexfoundry.org:10002/3rdparty/$image; done\n</code></pre>"},{"location":"releases/jakarta-lts-initial/#edgex-global-pipelinesedgexrelease","title":"edgex-global-pipelines@edgeXRelease","text":"<p>Various changes will be needed in vars/edgexRelease.groovy to support the lts release. See https://github.com/edgexfoundry/edgex-global-pipelines/blob/main/vars/edgeXRelease.groovy#L38. If we are doing an LTS release we should not create a tag, we need to create a long running branch where changes can be made without affecting the main branch.</p>"},{"location":"releases/jakarta-lts-initial/#changes-for-go-repositories","title":"Changes For Go Repositories","text":"<p>As called out in the LTS release process, for Go based projects, we will switch to Go vendoring for dependencies. This will give us 100% confidence that the dependencies will always be available in the LTS release and allow for easy patching and rebuilding.</p> <ul> <li>If the release is an LTS release and the LTS branch does not exist, we will need to run something similar to the following:</li> </ul> <pre><code>git checkout -b &lt;lts-release-name&gt;\ngrep -v vendor .gitignore &gt; .gitignore.tmp\nmv .gitignore.tmp .gitignore\nmake vendor\ngit add .\ngit commit -m \"ci(lts-release): LTS release v&lt;VERSION&gt; @&lt;commitId from release yaml&gt;\"\ngit push origin &lt;lts-release-name&gt;\n</code></pre> <ul> <li>If the release is an LTS release and the LTS branch does exist, we will need to run something similar to the following:</li> </ul> <pre><code>git checkout &lt;lts-release-name&gt;\ngit commit --allow-empty -m \"ci(lts-release): LTS release v&lt;VERSION&gt; @&lt;commitId from release yaml&gt;\"\ngit push origin &lt;lts-release-name&gt;\n</code></pre>"},{"location":"releases/jakarta-lts-initial/#changes-for-c-repositories","title":"Changes For C Repositories","text":"<p>There is no dependency management for C based projects, so no dependency management changes are needed. We will need to branch and push though.</p> <ul> <li>If the release is an LTS release and the LTS branch does not exist, we will need to run something similar to the following:</li> </ul> <pre><code>git checkout -b &lt;lts-release-name&gt;\ngit commit --allow-empty -m \"ci(lts-release): LTS release v&lt;VERSION&gt; @&lt;commitId from release yaml&gt;\"\ngit push origin &lt;lts-release-name&gt;\n</code></pre> <ul> <li>If the release is an LTS release and the LTS branch does exist, we will need to run something similar to the following:</li> </ul> <pre><code>git checkout &lt;lts-release-name&gt;\ngit commit --allow-empty -m \"ci(lts-release): LTS release v&lt;VERSION&gt; @&lt;commitId from release yaml&gt;\"\ngit push origin &lt;lts-release-name&gt;\n</code></pre>"},{"location":"releases/jakarta-lts-initial/#edgex-global-pipelines-general-changes","title":"edgex-global-pipelines General Changes","text":""},{"location":"releases/jakarta-lts-initial/#semver-notes-and-noop-builds","title":"Semver notes and noop builds","text":"<ul> <li> <p>Git semver will continue to be used for lts releases. After the initial release a pre-release dev tag will be created as usual. However, we have to introduce the concept of a noop (no operation) build due to the fact we are branching and tagging. We can use the commit message as a way to determine a noop build. The flow will go something like this:</p> <ol> <li>1st build, triggered by push of lts branch to GitHub: No op, no semver needed</li> <li>edgeXRelease creates force creates tag 2.1.0</li> <li>2nd build, triggered by edgeXRelease and builds the 2.1.0 code and pushes the release to Nexus</li> <li>Bump semver to 2.1.1-dev.1</li> </ol> </li> <li> <p>vars/edgex.groovy</p> </li> <li>Potentially need to add a new method similar to <code>isReleaseStream()</code> called <code>isLTS()</code>.</li> <li>Add method or modify getGoLangBaseImage() to return the proper released ci-build-image if this is an LTS release</li> <li>vars/edgeXBuildGoApp.groovy</li> <li>For LTS releases we need to use the released CI base build image referenced in the ci-build-images section. So we will need to modify this method prepBaseBuildImage() to return the proper base build image if the release is an LTS release. Will call <code>edgex</code> function above.</li> <li>vars/edgeXBuildGoParallel.groovy</li> <li>For LTS releases we need to use the released CI base build image referenced in the ci-build-images section. So we will need to modify this method prepBaseBuildImage() to return the proper base build image if the release is an LTS release. Will call <code>edgex</code> function above.</li> <li>vars/edgeXBuildCApp.groovy</li> <li>This will be the most complicated change. We will need to release/archive the build images created from the Dockerfile.build. These images will need to be pushed to nexus release and then used as the base images for all subsequent LTS builds. This will ensure we have 100% reproducibility of the C repositories. For example we will need to create a <code>device-coap-c</code> specific docker image will all build dependencies archived in the image.</li> <li>A new stage will need to be added to the pipeline to release the docker build images. This stage can either be triggered by a new parameter to the pipeline, or can potentially be triggered by a special commit message. Since we are already doing a special commit message for the initial push, the commit message may be the correct approach.</li> <li>Changes will be required to the prepBaseBuildImage() function, to use repo level build images if we are on an LTS branch.</li> </ul>"},{"location":"releases/jakarta-release-stages/","title":"Jakarta Release Stages","text":""},{"location":"releases/jakarta-release-stages/#release-architecture","title":"Release Architecture","text":""},{"location":"releases/jakarta-release-stages/#pre-lts-flow","title":"Pre-LTS Flow","text":""},{"location":"releases/jakarta-release-stages/#post-lts-flow","title":"Post-LTS Flow","text":""},{"location":"releases/jakarta-release-stages/#c-based-services","title":"C Based Services","text":""},{"location":"releases/jakarta-release-stages/#release-flow","title":"Release Flow","text":"<ul> <li>\ud83c\udd95 edgeXRelease: creates and pushes \"jakarta\" branch at specific git sha</li> <li>The push of the tag triggers new LTSRelease build</li> <li>Job: https://jenkins.edgexfoundry.org/blue/organizations/jenkins/edgexfoundry%2Fdevice-coap-c/detail/lts-test/19/pipeline/81</li> <li>\"LTS Release Build\", builds project specific relevant ci build images (x86_64, arm64) will all dependencies bundled</li> <li>Images are pushed to nexus release, i.e. nexus3.edgexfoundry.org:10002/device-coap-c-builder-{ARCH}:{GIT SHA}</li> <li>[Existing] edgeXRelease: tags git sha with release version e.g. 2.1.0</li> <li>[Existing] edgeXRelease: stages build artifact, i.e. triggers device-coap-c/jakarta job</li> <li>\ud83c\udd95 If this is a C build and LTS we will need to wait until the first LTSRelease build is done before running this build. New function <code>edgex.waitForImages</code> is used to wait until builder images are ready.</li> <li>Job: https://jenkins.edgexfoundry.org/blue/organizations/jenkins/edgexfoundry%2Fdevice-coap-c/detail/lts-test/20/pipeline/154</li> <li>[Existing] edgeXRelease: Bump Semver, i.e. next dev tag 2.1.1-dev.1</li> </ul>"},{"location":"releases/jakarta-release-stages/#pr-fixes-regular-dev-process","title":"PR Fixes (Regular Dev Process)","text":"<p>PR is open in fork as normal, but target branch will be LTS (jakarta) branch</p> <ul> <li>[Existing] User open's PR as normal for fix, etc https://jenkins.edgexfoundry.org/blue/organizations/jenkins/edgexfoundry%2Fdevice-coap-c/detail/PR-27/7/pipeline/213</li> <li>\ud83c\udd95 Pipeline will detect the merge target is an LTS branch and will use released ci build image from the release process rather than build a ci image on the fly</li> <li> <p><code>prepBaseBuildImage()</code> was the perfect abstraction to do this!</p> <pre><code>docker pull nexus3.edgexfoundry.org:10002/device-coap-c-builder-x86_64:{GIT SHA}\ndocker tag nexus3.edgexfoundry.org:10002/device-coap-c-builder-x86_64:{GIT SHA} ci-base-image-x86_64\n</code></pre> <pre><code>docker pull nexus3.edgexfoundry.org:10002/device-coap-c-builder-arm64:{GIT SHA}\ndocker tag nexus3.edgexfoundry.org:10002/device-coap-c-builder-arm64:{GIT SHA} ci-base-image-arm64\n</code></pre> </li> </ul>"},{"location":"releases/jakarta-release-stages/#main-branch-regular-dev-process","title":"Main Branch (Regular Dev Process)","text":"<p>PR open against the main branch, no regressions introduced: https://jenkins.edgexfoundry.org/blue/organizations/jenkins/edgexfoundry%2Fdevice-coap-c/detail/PR-29/2/pipeline</p>"},{"location":"releases/jakarta-release-stages/#go-based-services","title":"Go based services","text":""},{"location":"releases/jakarta-release-stages/#release-flow_1","title":"Release Flow","text":"<ul> <li>\ud83c\udd95 edgeXRelease: creates and pushes \"jakarta\" branch at specific git sha</li> <li>The push of the tag triggers new LTSRelease build</li> <li>Job: https://jenkins.edgexfoundry.org/blue/organizations/jenkins/edgexfoundry%2Fsample-service/detail/lts-test/24/pipeline</li> <li>\"LTS Release Build\" will be a no op build in the case of Golang</li> <li>[Existing] edgeXRelease: tags git sha with release version e.g. 2.1.0</li> <li>[Existing] edgeXRelease: stages build artifact, i.e. triggers sample-service/jakarta job</li> <li>\ud83c\udd95 No wait needed as of yet, but maybe will need something in the future</li> <li>Job: https://jenkins.edgexfoundry.org/blue/organizations/jenkins/edgexfoundry%2Fsample-service/detail/lts-test/25/pipeline/147 (need to add lts branches to isReleaseStream)</li> <li>[Existing] edgeXRelease: Bump Semver, i.e. next dev tag 2.1.1-dev.1</li> </ul>"},{"location":"releases/jakarta-release-stages/#pr-fixes-regular-dev-process_1","title":"PR Fixes (Regular Dev Process)","text":"<p>PR is open in fork as normal, but target branch will be LTS (jakarta) branch</p> <ul> <li>[Existing] User open's PR as normal for fix, etc https://jenkins.edgexfoundry.org/blue/organizations/jenkins/edgexfoundry%2Fsample-service/detail/PR-135/9/pipeline</li> <li> <p>\ud83c\udd95 getGolangBaseImage will return Go LTS image that DevOps manually releases into Nexus release</p> <pre><code>docker build -t ci-base-image-x86_64 -f Dockerfile --build-arg BASE=nexus3.edgexfoundry.org:10002/edgex-devops/edgex-golang-base:1.16-alpine-lts --build-arg 'MAKE=echo noop' --target=builder .\n</code></pre> <pre><code>docker build -t ci-base-image-arm64 -f Dockerfile --build-arg BASE=nexus3.edgexfoundry.org:10002/edgex-devops/edgex-golang-base-arm64:1.16-alpine-lts --build-arg MAKE=\"echo noop\" --target=builder .\n</code></pre> </li> </ul>"},{"location":"releases/jakarta-release-stages/#main-branch-regular-dev-process_1","title":"Main branch (Regular Dev Process)","text":"<p>PR open against the main branch, no regressions introduced: https://jenkins.edgexfoundry.org/blue/organizations/jenkins/edgexfoundry%2Fsample-service/detail/PR-136/1/pipeline</p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>More coming soon!</p> <ul> <li>Manual Version Bump</li> <li>Pull Request Sandbox Testing</li> </ul>"},{"location":"tutorials/docker-build-strategy/","title":"Docker Build Strategy","text":"<p>Docker is a great tool for the CI/CD ecosystem. As the EdgeX DevOps community, we made the decision early when designing the EdgeX Jenkins pipelines to make Docker the center of our build strategy. The advantage of using Docker as the build context is that it allows for creating reproducible builds from Jenkins to our local build environment. Thus creating a portable build environment and minimizing build errors between environments. The EdgeX Jenkins pipelines use Docker images as the context for any build. This Docker image is generated from the <code>Dockerfile.build</code> found at the root of every EdgeX repository. Any dependencies or packages required for testing or compilation needs to be added to the <code>Dockerfile.build</code> file.</p>"},{"location":"tutorials/docker-build-strategy/#local-testing","title":"Local Testing","text":"<p>If we want to test how the build will run on Jenkins we can follow these steps locally.</p>"},{"location":"tutorials/docker-build-strategy/#example","title":"Example","text":"<p>First we build the \"build image\" <code>edgex-ci-build-image</code></p> <pre><code>cd app-service-configurable\ndocker build -t edgex-ci-build-image -f Dockerfile.build\n</code></pre> <p>Now we run the build image with some make targets and bind mount our current directory to a folder called <code>/ws</code> (workspace)</p> <pre><code>docker run --rm -v $(pwd):/ws -w /ws edgex-ci-build-image sh -c 'make test build'\n</code></pre> <p>Or to put it into a convenient one-liner:</p> <pre><code>cd app-service-configurable\ndocker build -t edgex-ci-build-image -f Dockerfile.build . &amp;&amp; docker run --rm -v $(pwd):/ws -w /ws edgex-ci-build-image sh -c 'make test build'\n</code></pre> <pre><code>Sending build context to Docker daemon    127kB\nStep 1/8 : ARG BASE=golang:1.15-alpine\nStep 2/8 : FROM ${BASE}\n ---&gt; 1a87ceb1ace5\nStep 3/8 : LABEL license='SPDX-License-Identifier: Apache-2.0'   copyright='Copyright (c) 2019: Intel'\n ---&gt; Using cache\n ---&gt; 9f1aa172c1d7\nStep 4/8 : RUN sed -e 's/dl-cdn[.]alpinelinux.org/nl.alpinelinux.org/g' -i~ /etc/apk/repositories\n ---&gt; Using cache\n ---&gt; fec4da09e9ec\nStep 5/8 : RUN apk add --no-cache make git gcc libc-dev libsodium-dev zeromq-dev bash\n...\nSuccessfully built ce2be0b9fe31\nSuccessfully tagged edgex-ci-build-image:latest\nCGO_ENABLED=1 go test -coverprofile=coverage.out ./...\n?   github.com/edgexfoundry/app-service-configurable\n    [no test files]\nCGO_ENABLED=1 go build -ldflags \"-X github.com/edgexfoundry/app-functions-sdk-go/internal.SDKVersion=v1.2.1-dev.35 -X github.com/edgexfoundry/app-functions-sdk-go/internal.ApplicationVersion=0.0.0\" app-service-configurable\n</code></pre>"},{"location":"tutorials/docker-build-strategy/#tooling-caveats","title":"Tooling Caveats","text":"<p>Docker build images are Alpine based to save on disk space and bandwith and with that comes potential tooling incompatiblities. For example a number of pre-installed base packages on Alpine are the BusyBox versions of the tools. BusyBox versions can sometimes have different arguments than their GNU counterparts. For instance the <code>tar</code> command:</p>"},{"location":"tutorials/docker-build-strategy/#busybox-alpine","title":"BusyBox (Alpine)","text":"<pre><code>$ tar --help\nBusyBox v1.31.1 () multi-call binary.\n\nUsage: tar c|x|t [-ZzJjahmvokO] [-f TARFILE] [-C DIR] [-T FILE] [-X FILE] [--exclude PATTERN]... [FILE]...\n</code></pre>"},{"location":"tutorials/docker-build-strategy/#gnu-other-linux-distros","title":"GNU (Other linux distros)","text":"<pre><code>$ tar --help\nUsage: tar [OPTION...] [FILE]...\nGNU 'tar' saves many files together into a single tape or disk archive, and can\nrestore individual files from the archive.\n</code></pre> <p>This can lead to unexpected issues if say, for instance, you are depending on a specific flag provided by the tool. One option to fix this is to just use the BusyBox flags, however this may break when not running inside the Docker build image. Another option is to find the alternative package and install that version. For example, Alpine provides the GNU alternative <code>tar</code> binary under the <code>tar</code> Alpine package:</p> <pre><code>$ apk add --update tar\n$ tar --help\nUsage: tar [OPTION...] [FILE]...\nGNU 'tar' saves many files together into a single tape or disk archive, and can\nrestore individual files from the archive.\n</code></pre>"},{"location":"tutorials/docker-build-strategy/#the-jenkins-way","title":"The Jenkins Way","text":"<p>The above example is similar to how Jenkins runs the build with a few distinctions. First, the make test and make build commands are broken up into two stages. This is an important distinction because it allows for a more granular pipeline allowing for better error handling. The other distinction is that Jenkins takes advantage of a caching base layer image that is passed in at build time. Take a look at the Dockerfile.build. You will notice the <code>BASE</code> docker <code>ARG</code> at the top of the file.</p> <pre><code>ARG BASE=golang:1.15-alpine\nFROM ${BASE}\n...\n</code></pre> <p>This allows Jenkins to override the base image during the build with an image from Nexus helping to alleviate issues with DockerHub pull limits as well as random Docker pull failures. On Jenkins this happens in the Prep stage:</p> <pre><code>docker build -t ci-base-image-x86_64 \\\n  -f Dockerfile.build \\\n  --build-arg BASE=nexus3.edgexfoundry.org:10003/edgex-devops/edgex-golang-base:1.15-alpine \\\n  .\n</code></pre> <p>The DevOps WG team manages these Golang base images and the Dockerfile for the latest Golang image used can be found here: https://github.com/edgexfoundry/ci-build-images/tree/golang-1.15. This cache image contains most of the dependencies used in the majority of the pipelines allowing us to cache dependencies at the base image level and increasing builds speeds.</p> <p>After the base image is built the test and build stages run in a similar manner to the local testing scenario:</p> <pre><code>docker run -t -u 0:0 \\\n  -w /w/workspace/app-service-configurable/60 \\\n  -v /w/workspace/app-service-configurable/60:/w/workspace/app-service-configurable/60:rw,z \\\n  -v /w/workspace/app-service-configurable/60@tmp:/w/workspace/app-service-configurable/60@tmp:rw,z \\\n  ci-base-image-x86_64 ... make test\n</code></pre>"},{"location":"tutorials/docker-build-strategy/#next-steps","title":"Next steps","text":"<p>More information can be found by reading the documentation or source code of these pipelines:</p> <ul> <li>edgeXBuildGoApp source</li> <li>edgeXBuildGoParallel source</li> </ul>"},{"location":"tutorials/manual-bump/","title":"Manual Version Bump Process","text":"<p>Sometimes the version of the edgex-global-pipelines needs to be changed between <code>stable</code> and <code>experimental</code> tags in order to enhance and validate that the changes work as expected.</p> <p>The process documented here outlines the manual process for bumping the version and tag on the global libraries.</p>"},{"location":"tutorials/manual-bump/#committer-access-required","title":"Committer Access Required","text":"<p>You must have write access to the repo to perform this manual version bump process.  - Developer must be a member of the devops-core-team as per TSC approval  - Version info can be obtained through view of the Jenkins Pipeline log for last successful build</p> <pre><code>$ git clone git@github.com:edgexfoundry/edgex-global-pipelines.git\n$ cd edgex-global-pipelines\n$ ./resources/update-named-tag.sh &lt;version&gt; &lt;stable|experimental&gt;\n</code></pre>"},{"location":"tutorials/manual-bump/#click-on-image-below-to-view-ascii-recording-of-the-manual-version-bump-process","title":"Click on image below to view ASCII recording of the manual version bump process","text":""},{"location":"tutorials/pr-commit-for-testing/","title":"Pull Request Sandbox Testing","text":""},{"location":"tutorials/pr-commit-for-testing/#introduction","title":"Introduction","text":"<p>The EdgeX Jenkins Production Server and EdgeX Jenkins Sandbox Server are configured to use the <code>edgex-global-pipelines</code> library. The servers target either <code>stable</code> or <code>experimental</code> tags for Production and Sandbox servers respectively.</p> <p>To make functional testing of Jenkins Shared Pipeline Libraries more convenient, you can use a commit hash from a Pull Request into <code>edgex-global-pipelines</code> to override the default pipeline version that the Jenkins server is using. (<code>stable</code>/<code>experimental</code>)</p>"},{"location":"tutorials/pr-commit-for-testing/#step-1-create-draft-pr","title":"Step 1 - Create Draft PR","text":"<p>When you have changes you'd like to functionally test, open a Draft Pull Request from your forked repository of <code>edgex-global-pipelines</code> into <code>edgex-global-pipelines:main</code></p> <p>Make clear that this is a PR for functional testing purposes and is not meant to be merged.</p> <p></p>"},{"location":"tutorials/pr-commit-for-testing/#step-2-use-pr-commit-hash","title":"Step 2 - Use PR Commit Hash","text":"<p>Find the commit hash of your draft PR.</p> <p></p> <p>Place the commit hash into your Jenkinsfile that is under test. The EdgeX Sample-Service is a good place to functionally test shared libraries without affecting production code.</p> <p>Add the commit hash after the <code>'@'</code> in the explicit library import statement as shown below.</p> <pre><code>@Library(\"edgex-global-pipelines@7eba319\") _\n\nedgeXBuildGoApp (\n    project: 'sample-service',\n    goVersion: '1.15',\n    buildExperimentalDockerImage: true\n)\n</code></pre>"},{"location":"tutorials/pr-commit-for-testing/#step-3-execute-jenkinsfile","title":"Step 3 - Execute Jenkinsfile","text":"<p>When you execute your functional test build job on the sandbox, the commit hash of your PR will be shown as the commit used for the edgex-global-pipeline shared library. You will see a message similar to the following in your build job console output.</p> <pre><code>...\nLoading library edgex-global-pipelines@7eba319\nAttempting to resolve 7eba319 from remote references...\n...\n</code></pre>"},{"location":"tutorials/pr-commit-for-testing/#step-4-finishing-up","title":"Step 4 - Finishing Up","text":"<p>When you are satisfied that the content of your <code>edgex-global-pipelines</code> fork is functionally tested and ready to be merged, you can convert your draft PR into a real PR and add the appropriate reviewers.</p> <p>After your PR is merged to main, the <code>experimental</code> tag will point to your newest content. You might want to test your new code by switching back to the <code>experimental</code> tag in your Jenkinsfile.</p> <pre><code>@Library(\"edgex-global-pipelines@experimental\") _\n</code></pre> <p>Please clean up and close your PR after you have finished your functional testing.</p>"},{"location":"tutorials/unit-testing-best-practices/","title":"Unit Testing Best Practices","text":""},{"location":"tutorials/unit-testing-best-practices/#table-of-contents","title":"Table Of Contents","text":"<ul> <li>Unit Testing Declarative Pipelines</li> <li>Encapsulate Pipeline logic within Groovy functions</li> <li>Example</li> <li>Mocking Jenkins Dependencies</li> <li>Add plugin dependency to Gradle</li> <li>Mocking Environment Variables</li> <li>Testing environment variables</li> <li>Mock external shared library methods</li> <li>Integration Testing</li> <li>Mock errors</li> <li>Mock external shared library methods</li> <li>Call Graph Example</li> <li>References</li> </ul>"},{"location":"tutorials/unit-testing-best-practices/#unit-testing-declarative-pipelines","title":"Unit Testing Declarative Pipelines","text":"<p>The edgex-global-pipelines shared library leverages the Jenkins Spock framework for unit testing Jenkins pipeline scripts and functions. The Jenkins Spock unit test framework does not currently support unit testing of Jenkins Declarative Pipeline code.</p>"},{"location":"tutorials/unit-testing-best-practices/#encapsulate-pipeline-logic-within-groovy-functions","title":"Encapsulate Pipeline logic within Groovy functions","text":"<p>In order to facilitate unit testing of the edgex-global-pipelines shared library, the DevOps team has made a deliberate effort to to minimize the amount of scripting logic contained within Jenkins declarative pipelines. This is accomplished by encapsulating pipeline logic within a Groovy function and calling the function in the declarative pipeline step as needed. Localizing pipeline logic within Groovy functions enables the Jenkins Spock framework to provide greater test coverage of Pipeline logic.</p>"},{"location":"tutorials/unit-testing-best-practices/#example","title":"Example","text":"<p>An example this approach can be seen within the <code>Build -&gt; amd64 -&gt; Prep</code> stage of the edgeXBuildCApp Delcarative Pipeline. Note the logic for prepping the base build image is encapsulated into a method named <code>prepBaseBuildImage</code> and it is called within the declarative Pipeline. Also the <code>prepBaseBuildImage</code> function logic is thoroughly unit tested in the edgeXBuildCApp Spec</p>"},{"location":"tutorials/unit-testing-best-practices/#mocking-jenkins-dependencies","title":"Mocking Jenkins Dependencies","text":"<p>Always leverage the builtin capabilities of the Jenkins-Spock framework for mocking Jenkins plugins. For example, if you come across the following error when unit testing your code: <pre><code>java.lang.IllegalStateException: During a test, the pipeline step [stepName] was called but there was no mock for it.\n</code></pre> The error above denotes that the code under test calls a pipeline step <code>stepName</code> but there is no mock for it. You are able to explicitly mock the pipeline step using <code>explictlyMockPipelineStep</code> method available in the Jenkins-Spock framework. However it is recommended that the plugin that contains the corresponding step be added as a dependency in the <code>build.gradle</code> file. For instructions on how to do this, refer to the Add plugin dependency to Gradle section.</p>"},{"location":"tutorials/unit-testing-best-practices/#add-plugin-dependency-to-gradle","title":"Add plugin dependency to Gradle","text":"<ol> <li>Note the name of the Pipeline Step to add.</li> <li>Go to Pipeline Steps Reference page.</li> <li>Use your browser and search for the Pipeline Step within the page.</li> <li>If the Pipeline Step is found, click on the Pipeline that it belongs to, the page for the respective Pipeline should open.</li> <li>Under the heading click on the <code>View this plugin on the Plugins site</code> link, the plugins.jenkins.io page should open.</li> <li>In the plugins.jenkins.io page note the ID for the Pipeline. You will use this ID in the next step.</li> <li>Go to Maven Repository page.</li> <li>Enter the ID in the search, and locate the result from the results displayed, click on the respective link.</li> <li>In the page, click on the <code>Jenkins Releases</code> tab.</li> <li>If you know the version then click it, otherwise click on the latest version that is listed.</li> <li>In the Gradle tab, note the group, name and version.</li> <li>Edit the <code>build.gradle</code> file, add the dependency found above to the dependencies section.</li> </ol>"},{"location":"tutorials/unit-testing-best-practices/#mocking-environment-variables","title":"Mocking Environment Variables","text":"<p>Always ensure the source code under test uses one of the following idioms for getting or setting Environment Variables, doing this will simplify the ability to mock environment variables in the unit test: - Getting the value of an environment variable   - <code>env.VARIABLE</code>   - <code>env[VARIABLE]</code>   - <code>\"${env.VARIABLE}\"</code> - Setting the value of an environment variable   - <code>env.VARIABLE = VALUE</code>   - <code>env[VARIABLE] = VALUE</code></p>"},{"location":"tutorials/unit-testing-best-practices/#testing-environment-variables","title":"Testing environment variables","text":"<p>Within your unit tests, environment variables are set using the <code>.getBinding().setVariable('name', 'value')</code> idiom. Where the name is <code>env</code> and the value is a map you define within your unit test. The map should define all environment variables the code under test expects, likewise the map can be used to assert any environment variables that the code under test sets.</p> <p>A good example of this practice is the EdgeXSetupEnvironmentSpec</p>"},{"location":"tutorials/unit-testing-best-practices/#mock-external-shared-library-methods","title":"Mock external shared library methods","text":"<p>The <code>edgex-global-pipelines</code> Jenkins shared library consists of multiple scripts exposing methods for various functional areas, where each script is named after the particular functional area it serves. The shared library includes a <code>EdgeX</code> script that serves as utility script containing methods that are shared amongst other scripts. It is common practice for a method in one script call a method in another script, to mock the interaction you use the <code>explictlyMockPipelineVariable</code> to mock the script, then <code>getPipelineMock</code> method to verify the interaction or stub it if necessary.</p> <p>Mock the external script named <code>script</code>: <pre><code>explictlyMockPipelineVariable('script')\n</code></pre> It is recommended to mock all external scripts called within the script under test in the Test Spec setup.</p> <p>Get the script mock and stub the call to <code>method</code> to return <code>'value'</code> for any argument passed in: <pre><code>getPipelineMock('script.method').call(_) &gt;&gt; 'value'\n</code></pre></p>"},{"location":"tutorials/unit-testing-best-practices/#integration-testing","title":"Integration Testing","text":"<p>Integration Testing is defined as a type of testing where software modules are integrated logically and tested as a group. The Jenkins-Spock framework provides the ability to load any number of scripts to test within a given Spec Test. There are instances where performing integration tests is more practical, if you wish to do so then we recommend naming the Spec Test with <code>Int</code> as to differentiate between unit and integration tests.</p> <p>A good example of this practice is the EdgeXReleaseDockerImageIntSpec</p>"},{"location":"tutorials/unit-testing-best-practices/#mock-errors","title":"Mock errors","text":"<p>Always leverage <code>error</code> when wanting to conditionally terminate part of your script. Error is a Pipeline Step whose plugin has been added as a dependency to our project thus is already mocked by the framework. An example showing how you can assert that an error is thrown with a specific message: <pre><code>1 * getPipelineMock('error').call('error message')\n</code></pre></p>"},{"location":"tutorials/unit-testing-best-practices/#mock-external-shared-library-methods_1","title":"Mock external shared library methods","text":"<p>The difficulties of mocking functions within the same script under test have been described in the following issue: Issue 78. Due to the nature of how the scripts that comprise the <code>edgex-global-pipelines</code> shared library are written; where a deliberate intent is made to develop small, functionally cohesive methods that contribute to a single well-defined task. This development intent results in having scripts with multi-layered call graphs, where methods may call multiple methods from within the same script. We find that the workaround provided in the issue is complicated and doesn't scale well in our environment. For these reasons the method outlined below is being suggested.</p> <ol> <li>For the script under test, document its call graph. A call graph is a control flow graph, which represents calling relationships between methods in a script or program. Each node represents a method and each edge (f, g) indicates that method f calls method g. An example EdgeXReleaseGitTag call graph is depicted below.</li> <li>Create a second script with the same name as the original script with the word Util added to the end, for example <code>EdgeXReleaseGitTagUtil.groovy</code>.</li> <li>Analyze the call graph, methods that reside in odd numbered layers should continue to reside in the first script, methods at even numbered layers should be moved from the first script into the second script.</li> <li>Create a Spec Test for both scripts.</li> </ol> <p>Mocking of methods between both scripts follow the same pattern described for Mock external shared library methods. The only difference with this approach is that the scripts are (for the lack of a better word) name spaced for the respective functional area.</p>"},{"location":"tutorials/unit-testing-best-practices/#call-graph-example","title":"Call Graph Example","text":"<p>NOTE The approach outlined above is not recommended as the standard development approach, but as an alternative to re-writing the script under test if mocking of the internal method calls becomes unwieldy.</p>"},{"location":"tutorials/unit-testing-best-practices/#references","title":"References","text":"<ul> <li>Jenkins Spock Documentation</li> <li>Spock Framework Reference</li> <li>Jenkins Shared Libraries</li> </ul>"}]}